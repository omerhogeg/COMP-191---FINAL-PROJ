#use "code-gen.ml";;

let file_to_string f =
  let ic = open_in f in
  let s = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;

let string_to_asts s = List.map Semantics.run_semantics
                         (Tag_Parser.tag_parse_expressions
                            (Reader.read_sexprs s));;

let primitive_names_to_labels = 
  ["boolean?", "is_boolean"; "float?", "is_float"; "integer?", "is_integer"; "pair?", "is_pair";
   "null?", "is_null"; "char?", "is_char"; "vector?", "is_vector"; "string?", "is_string";
   "procedure?", "is_procedure"; "symbol?", "is_symbol"; "string-length", "string_length";
   "string-ref", "string_ref"; "string-set!", "string_set"; "make-string", "make_string";
   "vector-length", "vector_length"; "vector-ref", "vector_ref"; "vector-set!", "vector_set";
   "make-vector", "make_vector"; "symbol->string", "symbol_to_string"; 
   "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ";
   "car", "getCar"; "cdr", "getCdr"; "set-car!", "setCar"; "set-cdr!", "setCdr"; "cons", "labelCons";
   "apply","labelApply"];;

let make_prologue consts_tbl fvars_tbl =
  let get_const_address const =
    let getConstant (c, (a, s)) = c in
    let getAddress (c, (a, s)) = a in
    let found = ref [] in
    begin
      for i = 0 to (List.length consts_tbl - 1) do
        if getConstant (List.nth consts_tbl i) = const
          then
            found := !found @ [getAddress (List.nth consts_tbl i)]
      done;
      "const_tbl+" ^ (string_of_int (List.nth !found 0))
    end
  in
  let get_fvar_address const =
    let getFvar (f, i) = f in
    let getIndex (f, i) = i in
    let found = ref [] in
    begin
      for i = 0 to (List.length fvars_tbl - 1) do
        if getFvar (List.nth fvars_tbl i) = const
          then
            found := !found @ [getIndex (List.nth fvars_tbl i)]
      done;
      "fvar_tbl+8*" ^ (string_of_int (List.nth !found 0))
    end
  in
  let make_primitive_closure (prim, label) =
"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
    mov [" ^ (get_fvar_address prim)  ^ "], rax" in
  let make_constant (c, (a, s)) = s in
  
"
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"

section .bss
malloc_pointer:
    resq 1

section .data
const_tbl:
" ^ (String.concat "\n" (List.map make_constant consts_tbl)) ^ "

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS " ^ get_const_address Void ^ "
%define SOB_NIL_ADDRESS " ^ get_const_address (Sexpr Nil) ^ "
%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "

fvar_tbl:
" ^ (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "

global main
section .text
main:
    push rbp
    mov rbp, rsp
    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    jmp code_fragment

code_fragment:
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
" ^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels)) ^ "
 
";;

let epilogue = "
getCar:
    push rbp
    mov rbp, rsp

.is_pair:
    mov r15, PVAR(0)
    cmp byte [r15], T_PAIR
    jne .wrong_type
    CAR rax, r15
    jmp .return

.wrong_type:
    mov rax, 60
    syscall

.return:
    leave
    ret

getCdr:
    push rbp
    mov rbp, rsp

.is_pair:
    mov r15, PVAR(0)
    cmp byte [r15], T_PAIR
    jne .wrong_type
    CDR rax, r15
    jmp .return

.wrong_type:
    mov rax, 60
    syscall

.return:
    leave
    ret

setCar:
    push rbp
    mov rbp, rsp

.is_pair:
    mov r14, PVAR(0)
    mov r15, PVAR(1)
    cmp byte [r14], T_PAIR
    jne .wrong_type
    mov qword [r14+TYPE_SIZE], r15
    mov rax, SOB_VOID_ADDRESS
    jmp .return

.wrong_type:
    mov rax, 60
    syscall

.return:
    leave
    ret

setCdr:
    push rbp
    mov rbp, rsp

.is_pair:
    mov r14, PVAR(0)
    mov r15, PVAR(1)
    cmp byte [r14], T_PAIR
    jne .wrong_type
    mov qword [r14+TYPE_SIZE+WORD_SIZE], r15
    mov rax, SOB_VOID_ADDRESS
    jmp .return

.wrong_type:
    mov rax, 60
    syscall

.return:
    leave
    ret

labelCons:
    push rbp
    mov rbp, rsp
    mov r14, PVAR(0)
    mov r15, PVAR(1)
    MAKE_PAIR(rax, r14, r15)
    leave
    ret

labelApply:
    push rbp
    mov rbp, rsp

.isProcedure:
    mov r9, PVAR(0)
    cmp byte [r9], T_CLOSURE
    jne .not_closure

    mov r9, qword [rbp + 8 * 3] ; number of params
    mov r10, r9
    dec r10                     ; index of list
    mov r11, PVAR(r10)          ; list
    xor r12, r12                ; reset list counter

    push SOB_NIL_ADDRESS
.countListElements:
    cmp byte[r11], T_PAIR
    jne .finishCount
    inc r12
    CDR r11, r11
    jmp .countListElements

.finishCount:
    shl r12, 3
    sub rsp, r12
    shr r12, 3
    mov r11, PVAR(r10)
    xor r13, r13

.pushListElements:
    cmp r13, r12
    je .pushArgsStart
    CAR r14, r11
    CDR r11, r11
    mov [rsp + 8 * r13], r14
    inc r13
    jmp .pushListElements

.pushArgsStart:
    dec r10
.pushArgs:
    cmp r10, 0
    je .pushNandEnv
    push PVAR(r10)
    dec r10
    jmp .pushArgs

.pushNandEnv:
    dec r9
    dec r9
    add r9, r12
    push r9
    mov r10, qword [rbp + 8 * 4]
    CLOSURE_ENV r11, r10
    push r11
    CLOSURE_CODE r11, r10
    push qword [rbp + 8 * 1]
    push qword [rbp]
    add r9, 5
    SHIFT_FRAME_NO_REP r9
    pop rbp
    jmp r11

.not_closure:
    mov rax, 60
    syscall

.return:
    leave
    ret
";;

exception X_missing_input_file;;

try
  let infile = Sys.argv.(1) in
  let code = (file_to_string "stdlib.scm") ^ (file_to_string infile) in
  let asts = string_to_asts code in
  let consts_tbl = Code_Gen.make_consts_tbl asts in
  let fvars_tbl = Code_Gen.make_fvars_tbl asts in
  let generate = Code_Gen.generate consts_tbl fvars_tbl in
  let code_fragment = String.concat "\n\n"
                        (List.map
                           (fun ast -> (generate ast 0) ^ "call write_sob_if_not_void")
                           asts
                        )
                        ^ "\n" ^
                        "add rsp, 4*8" ^ "\n" ^
                        "pop rbp" ^ "\n" ^
                        "ret" ^ "\n"
                        in
  let provided_primitives = file_to_string "prims.s" in
                   
  print_string (
                  (make_prologue consts_tbl fvars_tbl)  ^
                  code_fragment ^ "\n" ^
                  provided_primitives ^ "\n" ^
                  epilogue
  )

with Invalid_argument(x) -> raise X_missing_input_file;;
