diff --git a/code-gen.ml b/code-gen.ml
index 0d1442c..205af5a 100644
--- a/code-gen.ml
+++ b/code-gen.ml
@@ -1,14 +1,686 @@
 #use "semantic-analyser.ml";;
 
 module type CODE_GEN = sig
-  val make_consts_tbl : expr' list -> (constant * ('a * string)) list
-  val make_fvars_tbl : expr' list -> (string * 'a) list
-  val generate : (constant * ('a * string)) list -> (string * 'a) list -> expr' -> string
+  val make_consts_tbl : expr' list -> (constant * (int * string)) list
+  val make_fvars_tbl : expr' list -> (string * int) list
+  val generate : (constant * (int * string)) list -> (string * int) list -> expr' -> int -> string
 end;;
 
 module Code_Gen : CODE_GEN = struct
-  let make_consts_tbl asts = raise X_not_yet_implemented;;
-  let make_fvars_tbl asts = raise X_not_yet_implemented;;
-  let generate consts fvars e = raise X_not_yet_implemented;;
+
+let sexprListForConstTable = ref [Void; Sexpr (Nil); Sexpr (Bool (false)); Sexpr (Bool (true))];;
+let sexprListForConstTableIncludingSubs = ref [Void; Sexpr (Nil); Sexpr (Bool (false)); Sexpr (Bool (true))];;
+let currentAddress = ref 6;;
+let tripleListForConstTable =
+  ref [
+        (Void, (0, "MAKE_VOID"));
+        (Sexpr (Nil), (1, "MAKE_NIL"));
+        (Sexpr (Bool (false)), (2, "MAKE_BOOL(0)"));
+        (Sexpr (Bool (true)), (4, "MAKE_BOOL(1)"))
+  ];;
+
+let varFreeForFVarTable =
+  ref [
+    "boolean?"; "float?"; "integer?"; "pair?"; "null?"; "char?"; "vector?"; "string?";
+    "procedure?"; "symbol?"; "string-length"; "string-ref"; "string-set!"; "make-string";
+    "vector-length"; "vector-ref"; "vector-set!"; "make-vector"; "symbol->string";
+    "char->integer"; "integer->char"; "eq?"; "+"; "*"; "-"; "/"; "<"; "="; "car";
+    "cdr"; "set-car!"; "set-cdr!"; "cons"; "apply"
+  ];;
+let index = ref 0;;
+let varFreeTupleForFVarTable = ref [];;
+
+let counterOfOr = ref (-1);;
+let counterOfIf = ref (-1);;
+let counterOfLambdaSimple = ref (-1);;
+let counterOfLambdaOpt = ref (-2);;
+let counterOfApplic = ref (-1);;
+let counterOfApplicTP = ref (-2);;
+
+let temp = ref [];;
+let tempCharList = ref [];;
+
+let rec scanSexprForConst sexpr = match sexpr with
+  | Bool (boolValue) -> sexprListForConstTable := !sexprListForConstTable
+  | Nil -> sexprListForConstTable := !sexprListForConstTable
+  | _ ->
+      begin
+        if List.mem (Sexpr (sexpr)) !sexprListForConstTable
+          then sexprListForConstTable := !sexprListForConstTable
+          else sexprListForConstTable := !sexprListForConstTable @ [Sexpr (sexpr)]
+      end;;
+
+let rec scanAstForConst ast = match ast with
+  | Const' (constType) ->
+
+      (match constType with
+        | Sexpr (sexprType) -> scanSexprForConst sexprType
+        | Void -> sexprListForConstTable := !sexprListForConstTable
+      )
+  | BoxSet' (varArg, exprArg) -> scanAstForConst exprArg
+  | If' (test, dit, dif) ->
+      begin
+        scanAstForConst test;
+        scanAstForConst dit;
+        scanAstForConst dif
+      end
+  | Seq' (exprList) -> List.iter (fun element -> scanAstForConst element) exprList
+  | Set' (varible, value) -> scanAstForConst value
+  | Def' (varible, value) -> scanAstForConst value
+  | Or' (exprList) -> List.iter (fun element -> scanAstForConst element) exprList
+  | LambdaSimple' (args, body) -> scanAstForConst body
+  | LambdaOpt' (args, additionalArg, body) -> scanAstForConst body
+  | Applic' (proc, exprList) ->
+      begin
+        scanAstForConst proc;
+        List.iter (fun element -> scanAstForConst element) exprList
+      end
+  | ApplicTP' (proc, exprList) ->
+      begin
+        scanAstForConst proc;
+        List.iter (fun element -> scanAstForConst element) exprList
+      end
+  | _ -> sexprListForConstTable := !sexprListForConstTable;;
+
+let rec makeSubConstant constantElement = match constantElement with
+  | Sexpr (Symbol (stringValue)) ->
+      begin
+        sexprListForConstTableIncludingSubs := !sexprListForConstTableIncludingSubs @ [Sexpr (String (stringValue))];
+        sexprListForConstTableIncludingSubs := !sexprListForConstTableIncludingSubs @ [constantElement];
+      end
+  | Sexpr (Pair (firstSexpr, secondSexpr)) -> begin
+                                                makeSubConstant (Sexpr (firstSexpr));
+                                                makeSubConstant (Sexpr (secondSexpr));
+                                                if List.mem constantElement !sexprListForConstTableIncludingSubs
+                                                  then sexprListForConstTableIncludingSubs := !sexprListForConstTableIncludingSubs
+                                                  else sexprListForConstTableIncludingSubs := !sexprListForConstTableIncludingSubs @ [constantElement];
+                                              end
+  | Sexpr (Vector (sexprList)) ->
+      begin
+        List.iter
+          (fun element -> makeSubConstant (Sexpr (element)))
+          sexprList;
+        if List.mem constantElement !sexprListForConstTableIncludingSubs
+          then sexprListForConstTableIncludingSubs := !sexprListForConstTableIncludingSubs
+          else sexprListForConstTableIncludingSubs := !sexprListForConstTableIncludingSubs @ [constantElement];
+      end
+  | x ->
+      if List.mem x !sexprListForConstTableIncludingSubs
+        then sexprListForConstTableIncludingSubs := !sexprListForConstTableIncludingSubs
+        else sexprListForConstTableIncludingSubs := !sexprListForConstTableIncludingSubs @ [x];;
+
+let searchAddressForMakeTriple sexprToSearch =
+  let getConstant (c, (a, s)) = c in
+  let getAddress (c, (a, s)) = a in
+  let found = ref [] in
+  begin
+    for i = 0 to (List.length !tripleListForConstTable - 1) do
+      if getConstant (List.nth !tripleListForConstTable i) = sexprToSearch
+        then
+          found := !found @ [getAddress (List.nth !tripleListForConstTable i)]
+    done;
+    List.nth !found 0
+  end;;
+
+let makeTriple constantElement = match constantElement with
+  | Sexpr (Number (numberValue)) ->
+      (match numberValue with
+        | Int (intValue) ->
+            begin
+              currentAddress := !currentAddress + 9;
+              tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 9, "MAKE_LITERAL_INT(" ^ (string_of_int intValue) ^ ")"))]
+            end
+        | Float (floatValue) ->
+            begin
+              currentAddress := !currentAddress + 9;
+              tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 9, "MAKE_LITERAL_FLOAT(" ^ (string_of_float floatValue) ^ ")"))]
+            end
+      )
+  | Sexpr (Char (charValue)) ->
+      begin
+        currentAddress := !currentAddress + 2;
+        (match charValue with
+          | '\n' -> tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 2, "MAKE_LITERAL_CHAR(CHAR_NEWLINE)"))]
+          | '\r' -> tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 2, "MAKE_LITERAL_CHAR(CHAR_RETURN)"))]
+          | '\t' -> tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 2, "MAKE_LITERAL_CHAR(CHAR_TAB)"))]
+          | '\x0c' -> tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 2, "MAKE_LITERAL_CHAR(CHAR_PAGE)"))]
+          | ' ' -> tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 2, "MAKE_LITERAL_CHAR(CHAR_SPACE)"))]
+          | '\x00' -> tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 2, "MAKE_LITERAL_CHAR(CHAR_NUL)"))]
+          | '\x27' -> tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 2, "MAKE_LITERAL_CHAR(39)"))]
+          | _ -> tripleListForConstTable := !tripleListForConstTable @ [(constantElement, (!currentAddress - 2, "MAKE_LITERAL_CHAR('" ^ (String.make 1 charValue) ^ "')"))]
+        )
+      end
+  | Sexpr (String (stringValue)) ->
+      (try
+          let x = searchAddressForMakeTriple constantElement in
+          temp := [(List.hd !temp)] @ [x]
+      with _ ->
+        begin
+          currentAddress := !currentAddress + 9 + (String.length stringValue);
+          for i = 0 to (String.length stringValue - 1) do
+            let currentChar = String.get stringValue i in
+            match currentChar with
+              | '\n' -> tempCharList := !tempCharList @ ["CHAR_NEWLINE"]
+              | '\r' -> tempCharList := !tempCharList @ ["CHAR_RETURN"]
+              | '\t' -> tempCharList := !tempCharList @ ["CHAR_TAB"]
+              | '\x0c' -> tempCharList := !tempCharList @ ["CHAR_PAGE"]
+              | ' ' -> tempCharList := !tempCharList @ ["CHAR_SPACE"]
+              | '\x00' -> tempCharList := !tempCharList @ ["CHAR_NUL"]
+              | '\x27' -> tempCharList := !tempCharList @ ["39"]
+              | _ ->  tempCharList := !tempCharList @ ["'" ^ (String.make 1 currentChar) ^ "'"]
+          done;
+          tripleListForConstTable := !tripleListForConstTable
+                                      @
+                                      [
+                                        (
+                                          constantElement,
+                                          (
+                                            !currentAddress - (String.length stringValue) - 9,
+                                            "MAKE_LITERAL_STRING_LIKE_VECTOR " ^ (String.concat ", " !tempCharList)
+                                          )
+                                        )
+                                      ];
+          tempCharList := []
+        end)
+  | Sexpr (Symbol (stringValue)) ->
+      begin
+        currentAddress := !currentAddress + 9;
+        tripleListForConstTable :=
+          !tripleListForConstTable
+          @
+          [(constantElement, (!currentAddress - 9, "MAKE_LITERAL_SYMBOL(const_tbl+" ^ string_of_int (searchAddressForMakeTriple (Sexpr(String(stringValue)))) ^ ")"))]
+      end
+  | Sexpr (Pair (car, cdr)) ->
+      begin
+        currentAddress := !currentAddress + 17;
+        tripleListForConstTable :=
+          !tripleListForConstTable
+          @
+          [(constantElement, (!currentAddress - 17, "MAKE_LITERAL_PAIR(const_tbl+" ^ string_of_int (searchAddressForMakeTriple (Sexpr(car))) ^ ", const_tbl+" ^ string_of_int (searchAddressForMakeTriple (Sexpr(cdr))) ^ ")"))]
+      end
+  | Sexpr (Vector ([])) ->
+      begin
+        currentAddress := !currentAddress + 9;
+        tripleListForConstTable :=
+          !tripleListForConstTable
+          @
+          [
+            (
+              constantElement,
+              (
+                (!currentAddress - 9),
+                "MAKE_LITERAL_VECTOR"
+              )
+            )
+          ]
+      end
+  | Sexpr (Vector (sexpList)) ->
+      begin
+        currentAddress := !currentAddress + 9 + (List.length sexpList) * 8;
+        let vectorElements = String.concat
+                              ""
+                              (
+                                List.map
+                                  (fun element -> "const_tbl+" ^ (string_of_int (searchAddressForMakeTriple (Sexpr(element)))) ^ ", ")
+                                  sexpList
+                              )
+        in
+        tripleListForConstTable :=
+          !tripleListForConstTable
+          @
+          [
+            (
+              constantElement,
+              (
+                (!currentAddress - 9 - (List.length sexpList) * 8),
+                "MAKE_LITERAL_VECTOR " ^ (String.sub vectorElements 0 (String.length vectorElements - 2))
+              )
+            )
+          ]
+      end
+  | _ -> currentAddress := !currentAddress;;
+
+let rec scanAstForVarFree ast = match ast with
+  | Var' (varType) ->
+      (match varType with
+        | VarFree (varFreeName) ->
+            if List.mem varFreeName !varFreeForFVarTable
+              then varFreeForFVarTable := !varFreeForFVarTable
+              else varFreeForFVarTable := !varFreeForFVarTable @ [varFreeName]
+        | _ -> varFreeForFVarTable := !varFreeForFVarTable
+      )
+  | If' (test, dit, dif) ->
+      begin
+        scanAstForVarFree test;
+        scanAstForVarFree dit;
+        scanAstForVarFree dif
+      end
+  | Seq' (exprList) -> List.iter (fun element -> scanAstForVarFree element) exprList
+  | Set' (varible, value) ->
+      begin
+        scanAstForVarFree varible;
+        scanAstForVarFree value
+      end
+  | Def' (varible, value) ->
+      begin
+        scanAstForVarFree varible;
+        scanAstForVarFree value
+      end
+  | Or' (exprList) -> List.iter (fun element -> scanAstForVarFree element) exprList
+  | LambdaSimple' (args, body) -> scanAstForVarFree body
+  | LambdaOpt' (args, additionalArg, body) -> scanAstForVarFree body
+  | Applic' (proc, exprList) ->
+      begin
+        scanAstForVarFree proc;
+        List.iter (fun element -> scanAstForVarFree element) exprList
+      end
+  | ApplicTP' (proc, exprList) ->
+      begin
+        scanAstForVarFree proc;
+        List.iter (fun element -> scanAstForVarFree element) exprList
+      end
+  | _ -> varFreeForFVarTable := !varFreeForFVarTable;;
+
+let makeTuple varElement =
+  begin
+    varFreeTupleForFVarTable := !varFreeTupleForFVarTable @ [(varElement, !index)];
+    index := !index + 1
+  end;;
+
+let make_consts_tbl asts =
+  begin
+    List.iter
+      scanAstForConst
+      asts;
+    List.iter
+      makeSubConstant
+      !sexprListForConstTable;
+    List.iter
+      makeTriple
+      !sexprListForConstTableIncludingSubs;
+    !tripleListForConstTable
+  end;;
+
+let make_fvars_tbl asts =
+  begin
+    List.iter
+      scanAstForVarFree
+      asts;
+    List.iter
+      makeTuple
+      !varFreeForFVarTable;
+    !varFreeTupleForFVarTable
+  end;;
+
+  let getAddressOfConst consts constElement =
+    let getConstant (c, (a, (s : string))) = c in
+    let getAddress (c, (a, (s : string))) = a in
+    let found = ref [] in
+    begin
+      for i = 0 to (List.length consts - 1) do
+        if getConstant (List.nth consts i) = constElement
+          then
+            found := !found @ [getAddress (List.nth consts i)]
+      done;
+      List.nth !found 0
+    end;;
+
+let getIndexOfFVar fvars fvarElement =
+  let getFvar (f, i) = f in
+  let getIndex (f, i) = i in
+  let found = ref [] in
+  begin
+    for i = 0 to (List.length fvars - 1) do
+      if getFvar (List.nth fvars i) = fvarElement
+        then
+          found := !found @ [getIndex (List.nth fvars i)]
+    done;
+    List.nth !found 0
+  end;;
+
+let rec generate consts fvars e depth = match e with
+  | Const' (constType) -> "mov rax, const_tbl+" ^ (string_of_int (getAddressOfConst consts constType)) ^ "\n"
+  | Var' (varType) ->
+      (match varType with
+        | VarFree (varFreeName) -> "mov rax, FVAR(" ^ (string_of_int (getIndexOfFVar fvars varFreeName)) ^ ")" ^ "\n"
+        | VarParam (_, minor) ->
+            "mov rax, " ^ (string_of_int minor) ^ "\n" ^
+            "add rax, 4" ^ "\n" ^
+            "mov rbx, 8" ^ "\n" ^
+            "mul rbx" ^ "\n" ^
+            "mov rax, qword [rbp + rax]" ^ "\n"
+        | VarBound (_, major, minor) ->
+            "mov rax, qword [rbp + 8 * 2]" ^ "\n" ^
+            "mov rax, qword [rax + 8 * " ^ (string_of_int major) ^ "]" ^ "\n" ^
+            "mov rax, qword [rax + 8 * " ^ (string_of_int minor) ^ "]" ^ "\n"
+      )
+  | Box' (insideVar) ->
+      (generate consts fvars (Var' (insideVar)) depth) ^
+      "MALLOC r15, WORD_SIZE" ^ "\n" ^
+      "mov [r15], rax" ^ "\n" ^
+      "mov rax, r15" ^ "\n"
+  | BoxGet' (insideVar) ->
+      (generate consts fvars (Var' (insideVar)) depth) ^
+      "mov rax, qword [rax]" ^ "\n"
+  | BoxSet' (insideVar, newVal) ->
+      (generate consts fvars newVal depth) ^
+      "push rax" ^ "\n" ^
+      (generate consts fvars (Var' (insideVar)) depth) ^
+      "pop qword [rax]" ^ "\n" ^
+      "mov rax, SOB_VOID_ADDRESS" ^ "\n"
+  | If' (test, dit, dif) ->
+      begin
+        counterOfIf := !counterOfIf + 1;
+        let currentCounter = !counterOfIf in
+        (generate consts fvars test depth) ^
+        "cmp rax, SOB_FALSE_ADDRESS" ^ "\n" ^
+        "je Lelse" ^ (string_of_int currentCounter) ^ "\n" ^
+        (generate consts fvars dit depth) ^
+        "jmp LexitIf" ^ (string_of_int currentCounter) ^ "\n" ^
+        "Lelse" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+        (generate consts fvars dif depth) ^
+        "LexitIf" ^ (string_of_int currentCounter) ^ ":" ^ "\n"
+      end
+  | Seq' (exprList) ->
+      List.fold_left
+        (fun acc element -> acc ^ (generate consts fvars element depth))
+        ""
+        exprList
+  | Set' (Var'(varType), value) ->
+      (match varType with
+        | VarFree (varFreeName) ->
+            (generate consts fvars value depth) ^
+            "mov qword FVAR(" ^ (string_of_int (getIndexOfFVar fvars varFreeName)) ^ "), rax" ^ "\n" ^
+            "mov rax, SOB_VOID_ADDRESS" ^ "\n"
+        | VarParam (_, minor) ->
+            (generate consts fvars value depth) ^
+            "mov qword [rbp + 8 * (4 + " ^ (string_of_int minor) ^ ")], rax" ^ "\n" ^
+            "mov rax, SOB_VOID_ADDRESS" ^ "\n"
+        | VarBound (_, major, minor) ->
+            (generate consts fvars value depth) ^
+            "mov rbx, qword [rbp + 8 * 2]" ^ "\n" ^
+            "mov rbx, qword [rbx + 8 * " ^ (string_of_int major) ^ "]" ^ "\n" ^
+            "mov qword [rbx + 8 * " ^ (string_of_int minor) ^ "], rax" ^ "\n" ^
+            "mov rax, SOB_VOID_ADDRESS" ^ "\n"
+      )
+  | Set' (x, y) -> " "
+  | Def' (Var'(varType), value) ->
+      (match varType with
+        | VarFree (varFreeName) ->
+          (generate consts fvars value depth) ^
+          "mov qword FVAR(" ^  (string_of_int (getIndexOfFVar fvars varFreeName)) ^ "), rax" ^ "\n" ^
+          "mov rax, SOB_VOID_ADDRESS" ^ "\n"
+        | _ -> " "
+      )
+  | Def' (x, y) -> " "
+  | Or' (exprList) ->
+      begin
+        counterOfOr := !counterOfOr + 1;
+        let currentCounter = !counterOfOr in
+        (
+          List.fold_left
+            (fun acc element -> acc ^
+                                (generate consts fvars element depth) ^ "\n" ^
+                                "cmp rax, SOB_FALSE_ADDRESS" ^ "\n" ^
+                                "jne LexitOr" ^ (string_of_int currentCounter) ^ "\n")
+            ""
+            (List.rev (List.tl (List.rev exprList)))
+        )
+        ^
+        (generate consts fvars (List.hd (List.rev exprList)) depth)^ "\n" ^
+        "LexitOr" ^ (string_of_int currentCounter) ^ ":" ^ "\n"
+      end
+  | LambdaSimple' (args, body) ->
+      begin
+        counterOfLambdaSimple := (!counterOfLambdaSimple + 2);
+        let currentCounter = !counterOfLambdaSimple in
+        (if depth = 0
+          then
+            "MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode" ^ (string_of_int currentCounter) ^ ")" ^ "\n" ^
+            "jmp Lcont" ^ (string_of_int currentCounter) ^ "\n" ^
+            "Lcode" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "push rbp" ^ "\n" ^
+            "mov rbp, rsp" ^ "\n" ^
+            (generate consts fvars body (depth + 1)) ^
+            "leave" ^ "\n" ^
+            "ret" ^ "\n" ^
+            "Lcont" ^ (string_of_int currentCounter) ^ ":" ^ "\n"
+          else
+            "mov rcx, qword[rbp + 8 * 2]" ^ "\n" ^ (* rcx = old env *)
+            "mov rdx, qword[rbp + 8 * 3]" ^ "\n" ^  (* rdx = number of params *)
+            "mov rbx, rbp" ^ "\n" ^
+            "add rbx, 32" ^ "\n" ^ (* rbx = address of param0 *)
+            (* allocate ExtEnv *)
+            "MALLOC r11, 8 * " ^ (string_of_int (depth + 1)) ^ "\n" ^
+            "MAKE_CLOSURE(rax, r11, Lcode" ^ (string_of_int currentCounter) ^ ")" ^ "\n" ^
+            "xor r12, r12" ^ "\n" ^
+            (* copy Env to ExtEnv *)
+            ".copyEnv" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "mov r13, qword [rcx + 8 * r12]" ^ "\n" ^
+            "mov qword [r11 + 8 * (r12 + 1)], r13" ^ "\n" ^
+            "inc r12" ^ "\n" ^
+            "cmp r12, " ^ (string_of_int depth) ^ "\n" ^
+            "jne .copyEnv" ^ (string_of_int currentCounter) ^ "\n" ^
+            (* check if need to allocate new vector of params *)
+            "mov qword[r11], SOB_NIL_ADDRESS" ^ "\n" ^
+            "cmp rdx, 0" ^ "\n" ^
+            "je .finish" ^ (string_of_int currentCounter) ^ "\n" ^
+            (* allocate new vector of params *)
+            "inc rdx" ^ "\n" ^
+            "shl rdx, 3" ^ "\n" ^
+            "MALLOC r8, rdx" ^ "\n" ^
+            "shr rdx, 3" ^ "\n" ^
+            "dec rdx" ^ "\n" ^
+            "mov qword[r11], r8" ^ "\n" ^ (* puts new vector in ExtEnv *)
+            "xor r10, r10" ^ "\n" ^
+            (* copying params to new vector *)
+            ".copyCurrentParam" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "mov r9, qword [rbx + 8 * r10]" ^ "\n" ^
+            "mov qword [r8 + 8 * r10], r9" ^ "\n" ^
+            "inc r10" ^ "\n" ^
+            "cmp rdx, r10" ^ "\n" ^
+            "jne .copyCurrentParam" ^ (string_of_int currentCounter) ^ "\n" ^
+            "mov qword [r8 + 8 * rdx], SOB_NIL_ADDRESS" ^ "\n" ^
+            (* finish *)
+            ".finish" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "jmp Lcont" ^ (string_of_int currentCounter) ^ "\n" ^
+            "Lcode" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "push rbp" ^ "\n" ^
+            "mov rbp, rsp" ^ "\n" ^
+            (generate consts fvars body (depth + 1)) ^
+            "leave" ^ "\n" ^
+            "ret" ^ "\n" ^
+            "Lcont" ^ (string_of_int currentCounter) ^ ":" ^ "\n"
+        )
+      end
+  | LambdaOpt' (args, additionalArg, body) ->
+      begin
+        counterOfLambdaOpt := (!counterOfLambdaOpt + 2);
+        let currentCounter = !counterOfLambdaOpt in
+        (if depth = 0
+          then
+            "MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode" ^ (string_of_int currentCounter) ^ ")" ^ "\n" ^
+            "jmp Lcont" ^ (string_of_int currentCounter) ^ "\n" ^
+            "Lcode" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "push rbp" ^ "\n" ^
+            "mov rbp, rsp" ^ "\n" ^
+            "mov rdx, qword[rbp + 8 * 3]" ^ "\n" ^
+            "cmp rdx, " ^ (string_of_int (List.length args)) ^ "\n" ^
+            "je finishAdjust" ^ (string_of_int currentCounter) ^ "\n" ^
+            "mov rax, SOB_NIL_ADDRESS" ^ "\n" ^
+            "mov r14, rdx" ^ "\n" ^
+            "sub r14, " ^ (string_of_int (List.length args)) ^ "\n" ^
+            "mov r15, r14" ^ "\n" ^
+            "add r15, 3" ^ "\n" ^
+            "add r15, " ^ (string_of_int (List.length args)) ^ "\n" ^
+            "shl r15, 3" ^ "\n" ^
+            "add r15, rbp" ^ "\n" ^
+            "mov rdi, [r15]" ^ "\n" ^
+            ".createPair" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "push rbx" ^ "\n" ^
+            "MAKE_PAIR(rbx, rdi, rax)" ^ "\n" ^
+            "mov rax, rbx" ^ "\n" ^
+            "pop rbx" ^ "\n" ^
+            "sub r15, 8" ^ "\n" ^
+            "mov rdi, [r15]" ^ "\n" ^
+            "dec r14" ^ "\n" ^
+            "cmp r14, 0" ^ "\n" ^
+            "jne .createPair" ^ (string_of_int currentCounter) ^ "\n" ^
+            "mov r14, 4" ^ "\n" ^
+            "add r14, " ^ (string_of_int (List.length args)) ^ "\n" ^
+            "shl r14, 3" ^ "\n" ^
+            "mov [rbp + r14], rax" ^ "\n" ^
+            "finishAdjust" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            (generate consts fvars body (depth + 1)) ^
+            "leave" ^ "\n" ^
+            "ret" ^ "\n" ^
+            "Lcont" ^ (string_of_int currentCounter) ^ ":" ^ "\n"
+          else
+            "mov rcx, qword[rbp + 8 * 2]" ^ "\n" ^ (* rcx = old env *)
+            "mov rdx, qword[rbp + 8 * 3]" ^ "\n" ^  (* rdx = number of params *)
+            "mov rbx, rbp" ^ "\n" ^
+            "add rbx, 32" ^ "\n" ^ (* rbx = address of param0 *)
+            (* allocate ExtEnv *)
+            "MALLOC r11, 8 * " ^ (string_of_int (depth + 1)) ^ "\n" ^
+            "MAKE_CLOSURE(rax, r11, Lcode" ^ (string_of_int currentCounter) ^ ")" ^ "\n" ^
+            "xor r12, r12" ^ "\n" ^
+            (* copy Env to ExtEnv *)
+            ".copyEnv" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "mov r13, qword [rcx + 8 * r12]" ^ "\n" ^
+            "mov qword [r11 + 8 * (r12 + 1)], r13" ^ "\n" ^
+            "inc r12" ^ "\n" ^
+            "cmp r12, " ^ (string_of_int depth) ^ "\n" ^
+            "jne .copyEnv" ^ (string_of_int currentCounter) ^ "\n" ^
+             (* check if need to allocate new vector of params *)
+             "mov qword[r11], SOB_NIL_ADDRESS" ^ "\n" ^
+             "cmp rdx, 0" ^ "\n" ^
+             "je .finish" ^ (string_of_int currentCounter) ^ "\n" ^
+            (* allocate new vector of params *)
+            "inc rdx" ^ "\n" ^
+            "shl rdx, 3" ^ "\n" ^
+            "MALLOC r8, rdx" ^ "\n" ^
+            "shr rdx, 3" ^ "\n" ^
+            "dec rdx" ^ "\n" ^
+            "mov qword[r11], r8" ^ "\n" ^ (* puts new vector in ExtEnv *)
+            "xor r10, r10" ^ "\n" ^
+            (* copying params to new vector *)
+            ".copyCurrentParam" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "mov r9, qword [rbx + 8 * r10]" ^ "\n" ^
+            "mov qword [r8 + 8 * r10], r9" ^ "\n" ^
+            "inc r10" ^ "\n" ^
+            "cmp rdx, r10" ^ "\n" ^
+            "jne .copyCurrentParam" ^ (string_of_int currentCounter) ^ "\n" ^
+            "mov qword [r8 + 8 * rdx], SOB_NIL_ADDRESS" ^ "\n" ^
+            (* finish *)
+            ".finish" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "jmp Lcont" ^ (string_of_int currentCounter) ^ "\n" ^
+            "Lcode" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "push rbp" ^ "\n" ^
+            "mov rbp, rsp" ^ "\n" ^
+            "mov rdx, qword[rbp + 8 * 3]" ^ "\n" ^
+            "cmp rdx, " ^ (string_of_int (List.length args)) ^ "\n" ^
+            "je finishAdjust" ^ (string_of_int currentCounter) ^ "\n" ^
+            "mov rax, SOB_NIL_ADDRESS" ^ "\n" ^
+            "mov r14, rdx" ^ "\n" ^
+            "sub r14, " ^ (string_of_int (List.length args)) ^ "\n" ^
+            "mov r15, r14" ^ "\n" ^
+            "add r15, 3" ^ "\n" ^
+            "add r15, " ^ (string_of_int (List.length args)) ^ "\n" ^
+            "shl r15, 3" ^ "\n" ^
+            "add r15, rbp" ^ "\n" ^
+            "mov rdi, [r15]" ^ "\n" ^
+            ".createPair" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            "push rbx" ^ "\n" ^
+            "MAKE_PAIR(rbx, rdi, rax)" ^ "\n" ^
+            "mov rax, rbx" ^ "\n" ^
+            "pop rbx" ^ "\n" ^
+            "sub r15, 8" ^ "\n" ^
+            "mov rdi, [r15]" ^ "\n" ^
+            "dec r14" ^ "\n" ^
+            "cmp r14, 0" ^ "\n" ^
+            "jne .createPair" ^ (string_of_int currentCounter) ^ "\n" ^
+            "mov r14, 4" ^ "\n" ^
+            "add r14, " ^ (string_of_int (List.length args)) ^ "\n" ^
+            "shl r14, 3" ^ "\n" ^
+            "mov [rbp + r14], rax" ^ "\n" ^
+            "finishAdjust" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+            (generate consts fvars body (depth + 1)) ^
+            "leave" ^ "\n" ^
+            "ret" ^ "\n" ^
+            "Lcont" ^ (string_of_int currentCounter) ^ ":" ^ "\n"
+        )
+      end
+  | Applic' (proc, exprList) ->
+      begin
+        counterOfApplic := !counterOfApplic + 2;
+        let currentCounter = !counterOfApplic in
+        "push SOB_NIL_ADDRESS" ^ "\n" ^
+        List.fold_right
+          (fun element acc ->
+            acc ^
+            (generate consts fvars element depth) ^
+            "push rax" ^ "\n"
+          )
+          exprList
+          ""
+        ^
+        "push " ^ string_of_int (List.length exprList) ^ "\n" ^
+        (generate consts fvars proc depth) ^
+        "cmp byte [rax], T_CLOSURE" ^ "\n" ^
+        "jne LnotClosureOfApplic" ^ (string_of_int currentCounter) ^ "\n" ^
+        "CLOSURE_ENV rbx, rax" ^ "\n" ^
+        "push rbx" ^ "\n" ^
+        "CLOSURE_CODE rbx, rax" ^ "\n" ^
+        "call rbx" ^ "\n" ^
+        "add rsp, 8" ^ "\n" ^
+        "pop rbx" ^ "\n" ^
+        "shl rbx, 3" ^ "\n" ^
+        "add rsp , rbx" ^ "\n" ^
+        "pop rbx" ^ "\n" ^
+        "jmp LendApplic" ^ (string_of_int currentCounter) ^ "\n" ^
+        "LnotClosureOfApplic" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+        "pop rbx" ^ "\n" ^
+        "shl rbx, 3" ^ "\n" ^
+        "add rsp, rbx" ^ "\n" ^
+        "pop rax" ^ "\n" ^
+        "mov rax, 60" ^ "\n" ^
+        "syscall" ^ "\n" ^
+        "LendApplic" ^ (string_of_int currentCounter) ^ ":" ^ "\n"
+      end
+  | ApplicTP' (proc, exprList) ->
+      begin
+        counterOfApplicTP := !counterOfApplicTP + 2;
+        let currentCounter = !counterOfApplicTP in
+        "push SOB_NIL_ADDRESS" ^ "\n" ^
+        List.fold_right
+          (fun element acc ->
+            acc ^
+            (generate consts fvars element depth) ^
+            "push rax" ^ "\n"
+          )
+          exprList
+          ""
+        ^
+        "push " ^ string_of_int (List.length exprList) ^ "\n" ^
+        (generate consts fvars proc depth) ^
+        "cmp byte [rax], T_CLOSURE" ^ "\n" ^
+        "jne LnotClosureOfApplic" ^ (string_of_int currentCounter) ^ "\n" ^
+        "CLOSURE_ENV rbx, rax" ^ "\n" ^
+        "push rbx" ^ "\n" ^
+        "CLOSURE_CODE rbx, rax" ^ "\n" ^
+        "push qword [rbp + 8 * 1]" ^ "\n" ^
+        "push qword[rbp]" ^ "\n" ^
+        "SHIFT_FRAME " ^ string_of_int ((List.length exprList) + 5) ^ "\n" ^
+        "pop rbp" ^ "\n" ^
+        "jmp rbx" ^ "\n" ^
+        "LnotClosureOfApplic" ^ (string_of_int currentCounter) ^ ":" ^ "\n" ^
+        "pop rbx" ^ "\n" ^
+        "shl rbx, 3" ^ "\n" ^
+        "add rsp , rbx" ^ "\n" ^
+        "pop rax" ^ "\n" ^
+        "mov rax, 60" ^ "\n" ^
+        "syscall" ^ "\n" ^
+        "LendApplic" ^ (string_of_int currentCounter) ^ ":" ^ "\n"
+      end;;
 end;;
 
diff --git a/compiler.ml b/compiler.ml
index e724266..f0dcd5c 100644
--- a/compiler.ml
+++ b/compiler.ml
@@ -18,12 +18,37 @@ let primitive_names_to_labels =
    "vector-length", "vector_length"; "vector-ref", "vector_ref"; "vector-set!", "vector_set";
    "make-vector", "make_vector"; "symbol->string", "symbol_to_string"; 
    "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
-   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ"
-(* you can add yours here *)];;
+   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ";
+   "car", "getCar"; "cdr", "getCdr"; "set-car!", "setCar"; "set-cdr!", "setCdr"; "cons", "labelCons";
+   "apply","labelApply"];;
 
 let make_prologue consts_tbl fvars_tbl =
-  let get_const_address const = raise X_not_yet_implemented in
-  let get_fvar_address const = raise X_not_yet_implemented in
+  let get_const_address const =
+    let getConstant (c, (a, s)) = c in
+    let getAddress (c, (a, s)) = a in
+    let found = ref [] in
+    begin
+      for i = 0 to (List.length consts_tbl - 1) do
+        if getConstant (List.nth consts_tbl i) = const
+          then
+            found := !found @ [getAddress (List.nth consts_tbl i)]
+      done;
+      "const_tbl+" ^ (string_of_int (List.nth !found 0))
+    end
+  in
+  let get_fvar_address const =
+    let getFvar (f, i) = f in
+    let getIndex (f, i) = i in
+    let found = ref [] in
+    begin
+      for i = 0 to (List.length fvars_tbl - 1) do
+        if getFvar (List.nth fvars_tbl i) = const
+          then
+            found := !found @ [getIndex (List.nth fvars_tbl i)]
+      done;
+      "fvar_tbl+8*" ^ (string_of_int (List.nth !found 0))
+    end
+  in
   let make_primitive_closure (prim, label) =
 "    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
     mov [" ^ (get_fvar_address prim)  ^ "], rax" in
@@ -46,8 +71,8 @@ const_tbl:
 ;;; definitions in the epilogue to work properly
 %define SOB_VOID_ADDRESS " ^ get_const_address Void ^ "
 %define SOB_NIL_ADDRESS " ^ get_const_address (Sexpr Nil) ^ "
-%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "
-%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
+%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
+%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "
 
 fvar_tbl:
 " ^ (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "
@@ -55,6 +80,8 @@ fvar_tbl:
 global main
 section .text
 main:
+    push rbp
+    mov rbp, rsp
     ;; set up the heap
     mov rdi, GB(4)
     call malloc
@@ -70,9 +97,7 @@ main:
     push qword T_UNDEFINED
     push rsp
 
-    call code_fragment
-    add rsp, 4*8
-    ret
+    jmp code_fragment
 
 code_fragment:
     ;; Set up the primitive stdlib fvars:
@@ -84,25 +109,195 @@ code_fragment:
  
 ";;
 
-let epilogue = raise X_not_yet_implemented;;
+let epilogue = "
+getCar:
+    push rbp
+    mov rbp, rsp
+
+.is_pair:
+    mov r15, PVAR(0)
+    cmp byte [r15], T_PAIR
+    jne .wrong_type
+    CAR rax, r15
+    jmp .return
+
+.wrong_type:
+    mov rax, 60
+    syscall
+
+.return:
+    leave
+    ret
+
+getCdr:
+    push rbp
+    mov rbp, rsp
+
+.is_pair:
+    mov r15, PVAR(0)
+    cmp byte [r15], T_PAIR
+    jne .wrong_type
+    CDR rax, r15
+    jmp .return
+
+.wrong_type:
+    mov rax, 60
+    syscall
+
+.return:
+    leave
+    ret
+
+setCar:
+    push rbp
+    mov rbp, rsp
+
+.is_pair:
+    mov r14, PVAR(0)
+    mov r15, PVAR(1)
+    cmp byte [r14], T_PAIR
+    jne .wrong_type
+    mov qword [r14+TYPE_SIZE], r15
+    mov rax, SOB_VOID_ADDRESS
+    jmp .return
+
+.wrong_type:
+    mov rax, 60
+    syscall
+
+.return:
+    leave
+    ret
+
+setCdr:
+    push rbp
+    mov rbp, rsp
+
+.is_pair:
+    mov r14, PVAR(0)
+    mov r15, PVAR(1)
+    cmp byte [r14], T_PAIR
+    jne .wrong_type
+    mov qword [r14+TYPE_SIZE+WORD_SIZE], r15
+    mov rax, SOB_VOID_ADDRESS
+    jmp .return
+
+.wrong_type:
+    mov rax, 60
+    syscall
+
+.return:
+    leave
+    ret
+
+labelCons:
+    push rbp
+    mov rbp, rsp
+    mov r14, PVAR(0)
+    mov r15, PVAR(1)
+    MAKE_PAIR(rax, r14, r15)
+    leave
+    ret
+
+labelApply:
+    push rbp
+    mov rbp, rsp
+
+.isProcedure:
+    mov r9, PVAR(0)
+    cmp byte [r9], T_CLOSURE
+    jne .not_closure
+
+    mov r9, qword [rbp + 8 * 3] ; number of params
+    mov r10, r9
+    dec r10                     ; index of list
+    mov r11, PVAR(r10)          ; list
+    xor r12, r12                ; reset list counter
+
+    push SOB_NIL_ADDRESS
+.countListElements:
+    cmp byte[r11], T_PAIR
+    jne .finishCount
+    inc r12
+    CDR r11, r11
+    jmp .countListElements
+
+.finishCount:
+    shl r12, 3
+    sub rsp, r12
+    shr r12, 3
+    mov r11, PVAR(r10)
+    xor r13, r13
+
+.pushListElements:
+    cmp r13, r12
+    je .pushArgsStart
+    CAR r14, r11
+    CDR r11, r11
+    mov [rsp + 8 * r13], r14
+    inc r13
+    jmp .pushListElements
+
+.pushArgsStart:
+    dec r10
+.pushArgs:
+    cmp r10, 0
+    je .pushNandEnv
+    push PVAR(r10)
+    dec r10
+    jmp .pushArgs
+
+.pushNandEnv:
+    dec r9
+    dec r9
+    add r9, r12
+    push r9
+    mov r10, qword [rbp + 8 * 4]
+    CLOSURE_ENV r11, r10
+    push r11
+    CLOSURE_CODE r11, r10
+    push qword [rbp + 8 * 1]
+    push qword [rbp]
+    add r9, 5
+    SHIFT_FRAME_NO_REP r9
+    pop rbp
+    jmp r11
+
+.not_closure:
+    mov rax, 60
+    syscall
+
+.return:
+    leave
+    ret
+";;
 
 exception X_missing_input_file;;
 
 try
   let infile = Sys.argv.(1) in
-  let code =  (file_to_string "stdlib.scm") ^ (file_to_string infile) in
+  let code = (file_to_string "stdlib.scm") ^ (file_to_string infile) in
   let asts = string_to_asts code in
   let consts_tbl = Code_Gen.make_consts_tbl asts in
   let fvars_tbl = Code_Gen.make_fvars_tbl asts in
   let generate = Code_Gen.generate consts_tbl fvars_tbl in
   let code_fragment = String.concat "\n\n"
                         (List.map
-                           (fun ast -> (generate ast) ^ "\n    call write_sob_if_not_void")
-                           asts) in
+                           (fun ast -> (generate ast 0) ^ "call write_sob_if_not_void")
+                           asts
+                        )
+                        ^ "\n" ^
+                        "add rsp, 4*8" ^ "\n" ^
+                        "pop rbp" ^ "\n" ^
+                        "ret" ^ "\n"
+                        in
   let provided_primitives = file_to_string "prims.s" in
                    
-  print_string ((make_prologue consts_tbl fvars_tbl)  ^
-                  code_fragment ^
-                    provided_primitives ^ "\n" ^ epilogue)
+  print_string (
+                  (make_prologue consts_tbl fvars_tbl)  ^
+                  code_fragment ^ "\n" ^
+                  provided_primitives ^ "\n" ^
+                  epilogue
+  )
 
 with Invalid_argument(x) -> raise X_missing_input_file;;
diff --git a/compiler.s b/compiler.s
index 5c418e8..cd114cf 100644
--- a/compiler.s
+++ b/compiler.s
@@ -150,16 +150,16 @@
 ;;; from two pointers %3 and %4
 ;;; Stores result in register %1
 %macro MAKE_TWO_WORDS 4 
-        MALLOC %1, TYPE_SIZE+WORD_BYTES*2
+        MALLOC %1, TYPE_SIZE+WORD_SIZE*2
         mov byte [%1], %2
         mov qword [%1+TYPE_SIZE], %3
-        mov qword [%1+TYPE_SIZE+WORD_BYTES], %4
+        mov qword [%1+TYPE_SIZE+WORD_SIZE], %4
 %endmacro
 
 %macro MAKE_WORDS_LIT 3
 	db %1
-        dq %2
-        dq %3
+    dq %2
+    dq %3
 %endmacro
 
 %define MAKE_PAIR(r, car, cdr) \
@@ -729,3 +729,94 @@ write_sob_if_not_void:
 section .data
 .newline:
 	db CHAR_NEWLINE, 0
+
+
+; From here it's the additional code to this file
+
+%define FVAR(i) [fvar_tbl + i * WORD_SIZE]
+
+%macro MAKE_LITERAL 2
+	db %1
+	%2
+%endmacro
+
+%define MAKE_VOID db T_VOID
+%define MAKE_NIL db T_NIL
+%define MAKE_BOOL(val) MAKE_LITERAL T_BOOL, db val
+
+%define MAKE_LITERAL_INT(val) MAKE_LITERAL T_INTEGER, dq val
+%define MAKE_LITERAL_FLOAT(val) MAKE_LITERAL T_FLOAT, dq val
+%define MAKE_LITERAL_CHAR(val) MAKE_LITERAL T_CHAR, db val
+
+%macro MAKE_LITERAL_STRING 1
+	db T_STRING
+	dq (%%end_str - %%str)
+%%str:
+	db %1
+%%end_str:
+%endmacro
+
+%define MAKE_LITERAL_SYMBOL(val) MAKE_LITERAL T_SYMBOL, dq val
+
+%macro MAKE_LITERAL_VECTOR 0-*
+	db T_VECTOR
+	dq %0
+%rep %0
+	dq %1
+%rotate 1
+%endrep
+%endmacro
+
+%macro MAKE_LITERAL_STRING_LIKE_VECTOR 0-*
+	db T_STRING
+	dq (%%end_str - %%str)
+%%str:
+%rep %0
+	db %1
+%rotate 1
+%endrep
+%%end_str:
+%endmacro
+
+%define PARAM_COUNT qword [rbp + 3 * WORD_SIZE]
+
+%macro SHIFT_FRAME 1
+	push rax
+	mov rax, PARAM_COUNT
+	add rax, 5
+	mov r14, rax
+	shl r14, 3
+%assign i 1
+%rep %1
+	dec rax
+	mov r9, qword [rbp - WORD_SIZE * i]
+	mov qword [rbp + WORD_SIZE * rax], r9
+%assign i i+1
+%endrep
+	pop rax
+	add rsp, r14
+%endmacro
+
+%macro SHIFT_FRAME_NO_REP 1
+	push rax
+	mov rax, PARAM_COUNT
+	add rax, 5
+	mov r14, rax
+	shl r14, 3
+	mov rcx, %1
+	mov r15, 8
+%%copy:
+	cmp rcx, 0
+	je %%finish
+	dec rax
+	sub rbp, r15
+	mov r9, qword [rbp]
+	add rbp, r15
+	mov qword [rbp + WORD_SIZE * rax], r9
+	dec rcx
+	add r15, 8
+	jmp %%copy
+%%finish:
+	pop rax
+	add rsp, r14
+%endmacro
\ No newline at end of file
diff --git a/prims.s b/prims.s
index bd9d118..23f713d 100644
--- a/prims.s
+++ b/prims.s
@@ -7,7 +7,7 @@ is_boolean:
 
     cmp sil, T_BOOL
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
@@ -25,7 +25,7 @@ is_float:
 
     cmp sil, T_FLOAT
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
@@ -43,7 +43,7 @@ is_integer:
 
     cmp sil, T_INTEGER
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
@@ -61,7 +61,7 @@ is_pair:
 
     cmp sil, T_PAIR
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
@@ -79,7 +79,7 @@ is_null:
 
     cmp sil, T_NIL
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
@@ -97,7 +97,7 @@ is_char:
 
     cmp sil, T_CHAR
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
@@ -115,7 +115,7 @@ is_vector:
 
     cmp sil, T_VECTOR
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
@@ -133,7 +133,7 @@ is_string:
 
     cmp sil, T_STRING
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
@@ -151,7 +151,7 @@ is_procedure:
 
     cmp sil, T_CLOSURE
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
@@ -169,7 +169,7 @@ is_symbol:
 
     cmp sil, T_SYMBOL
     jne .wrong_type
-    mov rax, sob_true
+    mov rax, SOB_TRUE_ADDRESS
     jmp .return
 
 .wrong_type:
diff --git a/reader.ml b/reader.ml
index 0955b39..d0ef8be 100644
--- a/reader.ml
+++ b/reader.ml
@@ -37,20 +37,385 @@ let rec sexpr_eq s1 s2 =
   | Vector(l1), Vector(l2) -> List.for_all2 sexpr_eq l1 l2
   | _ -> false;;
   
-module Reader: sig
-  val read_sexpr : string -> sexpr
-  val read_sexprs : string -> sexpr list
-end
-= struct
-let normalize_scheme_symbol str =
-  let s = string_to_list str in
-  if (andmap
-	(fun ch -> (ch = (lowercase_ascii ch)))
-	s) then str
-  else Printf.sprintf "|%s|" str;;
-
-let read_sexpr string = raise X_not_yet_implemented ;;
-
-let read_sexprs string = raise X_not_yet_implemented;;
+  module Reader: sig
+    val read_sexpr : string -> sexpr
+    val read_sexprs : string -> sexpr list
+  end
+  = struct
+  let normalize_scheme_symbol str =
+    let s = string_to_list str in
+    if (andmap
+      (fun ch -> (ch = (lowercase_ascii ch)))
+      s) then str
+    else Printf.sprintf "|%s|" str;;
   
+(* Delimeters - Start *)
+
+let space = PC.const (fun ch -> ch <= ' ');;
+
+let whitespaces_star = PC.star (space);;
+
+(* Delimeters - End *)
+
+(* Boolean - Start *)
+
+let hashtag = PC.char '#';;
+
+let boolean =
+    let booleanOption = PC.disj (PC.char_ci 't') (PC.char_ci 'f') in
+    let getBoolean = PC.caten hashtag booleanOption in
+    let booleanProtected =
+        PC.not_followed_by
+            getBoolean
+            (PC.const (fun ch -> ch > ' ' && ch != '#' && ch != '(' && ch != ')' && ch != '[' && ch != ']' && ch != ',' && ch != ';'
+                        && ch != '\x27' && ch != '\x60' && ch != '\"' && ch != '\n'))
+    in
+    PC.pack booleanProtected (fun (a, b) -> match (lowercase_ascii b) with
+                                            | 't' -> Bool (true)
+                                            | 'f' -> Bool (false)
+                                            | _ -> raise PC.X_no_match);;
+
+(* Boolean - End *)
+
+(* Char - Start *)
+
+let charPrefix = PC.caten hashtag (PC.char '\\');;
+
+let visibleSimpleChar =
+  PC.pack
+    (PC.range '!' '~')
+    (fun c -> Char (c));;
+
+let namedChar =
+  PC.pack
+    (PC.disj_list [PC.word_ci "newline"; PC.word_ci "return"; PC.word_ci "tab"; PC.word_ci "page"; PC.word_ci "space" ; PC.word_ci "nul"])
+    (fun (nameCharList) -> match (list_to_string nameCharList) with
+                            | "newline" -> Char ('\n')
+                            | "return" -> Char ('\r')
+                            | "tab" -> Char ('\t')
+                            | "page" -> Char ('\x0c')
+                            | "space" -> Char (' ')
+                            | "nul" -> Char ('\x00')
+                            | _ -> raise PC.X_no_match);;
+
+let hexDigit = PC.disj (PC.range '0' '9') (PC.range_ci 'a' 'f');;
+
+let hexChar =
+  PC.pack
+    (PC.caten (PC.char_ci 'x') (PC.plus hexDigit))
+    (fun (x, ascii) -> Char (char_of_int (Scanf.sscanf (list_to_string ascii) "%x" (fun x -> x))));;
+
+let charLHS =
+    let getChar = PC.caten charPrefix (PC.disj_list [hexChar; namedChar; visibleSimpleChar]) in
+    let charProtector =
+        PC.not_followed_by
+        getChar
+        (PC.const (fun ch -> ch > ' ' && ch != '(' && ch != ')' && ch != '[' && ch != ']' && ch != ',' && ch != ';'
+                            && ch != '\x27' && ch != '\x60' && ch != '\"' && ch != '\n'))
+    in
+    PC.pack charProtector (fun ((charPrefixA, charPrefixB), actualChar) -> actualChar);;
+
+(* Char - End *)
+
+(* Number - Start *)
+
+let hexDigit = PC.disj  (PC.range '0' '9') (PC.range_ci 'a' 'f');;
+
+let sign = PC.disj  (PC.char '+') (PC.char '-');;
+
+let digit = PC.range '0' '9';;
+
+let natural = PC.plus digit;;
+
+let unwrapNumber wrappedNumber = match wrappedNumber with
+                                    | Number x -> x
+                                    | _ -> raise PC.X_no_match;;
+
+let unwrapInt wrappedInteger = match wrappedInteger with
+                                    | Int x -> x
+                                    | _ -> raise PC.X_no_match;;
+
+let integer =
+    let calc x = int_of_string (list_to_string x) in
+    PC.pack
+        (PC.caten (PC.maybe sign) natural)
+        (fun (maybeSign, numberString) -> match maybeSign with
+                                            | Some '+' -> Number (Int (calc numberString))
+                                            | Some '-' -> Number (Int ((calc numberString) * (-1)))
+                                            | None -> Number (Int (calc numberString))
+                                            | _ -> raise PC.X_no_match);;
+
+let floatNt =
+    PC.pack
+        (PC.caten (PC.maybe sign) (PC.caten natural (PC.caten (PC.char '.') natural)))
+        (fun (maybeSign, (intList, (point, fracList))) -> match maybeSign with
+                                            | Some '+' -> Number (Float (float_of_string ((list_to_string intList) ^ "." ^ (list_to_string fracList))))
+                                            | Some '-' -> Number (Float (float_of_string ((list_to_string intList) ^ "." ^ (list_to_string fracList)) *. (-1.0)))
+                                            | None -> Number (Float (float_of_string ((list_to_string intList) ^ "." ^ (list_to_string fracList))))
+                                            | _ -> raise PC.X_no_match);;
+
+let hexNatural = PC.plus hexDigit;;
+
+let hexPrefix = PC.caten hashtag (PC.char_ci 'x');;
+
+let hexInteger =
+    let calc x = (int_of_string (String.concat "" ["0x"; list_to_string x])) in
+    PC.pack
+        (PC.caten hexPrefix (PC.caten (PC.maybe sign) hexNatural))
+        (fun ((hexPrefixA, hexPrefixB), (maybeSign, digitList)) -> match maybeSign with
+                                                                    | Some '+' -> Number (Int (calc digitList))
+                                                                    | Some '-' -> Number (Int (calc digitList * (-1)))
+                                                                    | None -> Number (Int (calc digitList))
+                                                                    | _ -> raise PC.X_no_match);;
+
+let hexFloat =
+    let calc x y = float_of_string ("0x" ^ (list_to_string x) ^ "." ^ (list_to_string y)) in
+    PC.pack
+        (PC.caten hexPrefix (PC.caten (PC.maybe sign) (PC.caten hexNatural (PC.caten (PC.char '.') hexNatural))))
+        (fun (prefix , (maybeSign, (intHexList, (dot, fracHexList)))) ->
+            match maybeSign with
+            | Some '+' -> Number (Float (calc intHexList fracHexList))
+            | Some '-' -> Number (Float ((calc intHexList fracHexList) *. (-1.0)))
+            | None -> Number (Float (calc intHexList fracHexList))
+            | _ -> raise PC.X_no_match);;
+
+let scientificNotation =
+    PC.pack
+        (PC.caten (PC.disj floatNt integer) (PC.caten (PC.char_ci 'e')  integer))
+        (fun (builtNumber,(e,exponent)) -> match unwrapNumber builtNumber with
+                                            | Int x -> Number (Float (float_of_string ((string_of_int x) ^ "e" ^ (string_of_int (unwrapInt (unwrapNumber exponent))))))
+                                            | Float x -> Number (Float (float_of_string ((string_of_float x) ^ "e" ^ (string_of_int (unwrapInt (unwrapNumber exponent)))))))
+
+let numberLHS =
+    PC.not_followed_by
+    (PC.disj_list [scientificNotation; floatNt; integer; hexFloat; hexInteger])
+    (PC.const (fun ch -> ch > ' ' && ch != '(' && ch != ')' && ch != '[' && ch != ']' && ch != ',' && ch != ';'
+                            && ch != '\x27' && ch != '\x60' && ch != '\"' && ch != '\n'));;
+
+(* Number - End *)
+
+(* String - Start *)
+
+let stringLiteralChar =
+    PC.pack
+        (PC.const (fun ch -> ch != '\\' && ch != '\"'))
+        (fun (stringLC) -> match (stringLC) with
+                            | _ -> String (list_to_string [stringLC]));;
+
+let stringMetaChar =
+    PC.pack
+        (PC.disj_list [PC.word "\\\""; PC.word "\\\\"; PC.word_ci "\\t"; PC.word_ci "\\f"; PC.word "\\n"; PC.word "\\r"])
+        (fun (stringList) -> match (list_to_string stringList) with
+                                | "\\\\" -> String ("\\")
+                                | "\\\"" -> String ("\"")
+                                | "\\t" -> String ("\t")
+                                | "\\f" -> String ("\x0c")
+                                | "\\n" -> String ("\n")
+                                | "\\r" -> String ("\r")
+                                | _ -> raise PC.X_no_match);;
+
+let stringHexChar =
+    PC.pack
+        (PC.caten (PC.word_ci "\\x") (PC.caten (PC.plus hexDigit) (PC.char ';')))
+        (fun (backSlashX, (asciiList ,semiColon)) -> String (String.make 1 (char_of_int (int_of_string ("0x" ^ (list_to_string asciiList))))));;
+
+let stringChar = PC.disj_list [stringHexChar; stringMetaChar; stringLiteralChar];;
+
+let stringNt =
+    let unwrapString x = match x with
+                            | String wrappedString -> wrappedString
+                            | _ -> raise PC.X_no_match in
+    PC.pack
+        (PC.caten (PC.char '\"' ) (PC.caten (PC.star stringChar) (PC.char '\"')))
+        (fun (openQuote,(stringList,closeQuote)) -> String(String.concat "" (List.map unwrapString stringList)));;
+
+(* String - End *)
+
+(* Symbol - Start *)
+
+let symbol =
+    let punctuation = PC.disj_list [PC.char '!'; PC.char '$'; PC.char '^'; PC.char '*'; PC.char '-'; PC.char '_'; PC.char '='; PC.char '+'; PC.char '<'; PC.char '>'; PC.char '?'; PC.char '/'; PC.char ':'] in
+    let symbolChar = PC.disj_list [PC.range '0' '9'; PC.range_ci 'a' 'z'; punctuation] in
+    let getSymbol = (PC.plus symbolChar) in
+    let symbolProtected =
+        PC.not_followed_by
+        getSymbol
+        (PC.const (fun ch -> ch > ' ' && ch != '#' && ch != '(' && ch != ')' && ch != '[' && ch != ']' && ch != ',' && ch != ';'
+                                && ch != '\x27' && ch != '\x60' && ch != '\"' && ch != '\n'))
+        in
+        PC.pack symbolProtected (fun (symbolList) -> Symbol (list_to_string (List.map lowercase_ascii symbolList)));;
+
+(* Symbol - End *)
+
+(* Sexpr - Start *)
+
+let rec sexprLHS inputString =
+    let lineComment =
+        PC.pack
+            (PC.caten (PC.char ';') (PC.caten (PC.star (PC.const (fun ch -> ch != '\n' && ch != '\x03'))) (PC.disj (PC.char '\n') (PC.char '\x03'))))
+            (fun (_) -> Char (' '))
+    in
+    let sexprComment =
+        PC.pack
+            (PC.caten (PC.word "#;") (PC.delayed (fun () -> sexprLHS)))
+            (fun (_) -> Char (' '))
+    in
+    let packed =
+        PC.pack
+        (PC.caten whitespaces_star (PC.caten (PC.star (PC.caten whitespaces_star (PC.disj lineComment sexprComment))) (PC.caten whitespaces_star (PC.caten (PC.disj_list [boolean; charLHS; numberLHS; threeDots; symbol; nil; listOfSexpr; dottedListOfSexpr; vectorOfSexpr; stringNt; quoted; quasiQuoted; unquoted; unquoteAndSpliced]) (PC.caten whitespaces_star (PC.caten (PC.star (PC.disj lineComment sexprComment)) whitespaces_star))))))
+            (fun (leftSpaces, (starComment, (midSpaces1 ,(actualSexpr, (midSpaces2, (starLineComment2, rightSpaces)))))) -> actualSexpr)
+    in
+    packed inputString
+
+(* Sexpr - End *)
+
+(* List - Start *)
+
+and listOfSexpr inputString1 =
+    let packed =
+        PC.pack
+            (PC.disj
+                (PC.caten (PC.char '\x28') (PC.caten (PC.star (PC.caten whitespaces_star (PC.delayed (fun () -> sexprLHS)))) (PC.caten whitespaces_star (PC.char '\x29'))))
+                (PC.caten (PC.char '\x5b') (PC.caten (PC.star (PC.caten whitespaces_star (PC.delayed (fun () -> sexprLHS)))) (PC.caten whitespaces_star (PC.char '\x5d')))))
+            (fun
+                (lapren, (sexprList, spacesWithLparen)) ->
+                List.fold_right (fun (spaceList, actualSexpr) acc -> Pair (actualSexpr, acc))
+                sexprList Nil
+            )
+    in
+    packed inputString1
+
+(* List - End *)
+
+(* DottedList - Start *)
+
+and dottedListOfSexpr inputString2 =
+    let packed =
+        PC.pack
+            (PC.disj
+                (PC.caten (PC.char '\x28') (PC.caten (PC.plus (PC.caten whitespaces_star (PC.delayed (fun () -> sexprLHS)))) (PC.caten (PC.caten whitespaces_star (PC.char '.')) (PC.caten (PC.caten whitespaces_star sexprLHS) (PC.caten whitespaces_star (PC.char '\x29'))))))
+                (PC.caten (PC.char '\x5b') (PC.caten (PC.plus (PC.caten whitespaces_star (PC.delayed (fun () -> sexprLHS)))) (PC.caten (PC.caten whitespaces_star (PC.char '.')) (PC.caten (PC.caten whitespaces_star sexprLHS) (PC.caten whitespaces_star (PC.char '\x5d')))))))
+            (fun
+                (lapren, (leftToPoint ,(point,( (additionalElementSpaces ,additionalElement ),rparen )) ) ) ->
+                List.fold_right (fun (elementSpaces, actualElement) acc -> Pair (actualElement, acc))
+                leftToPoint additionalElement
+            )
+            in
+    packed inputString2
+
+(* DottedList - End *)
+
+(* Vector - Start *)
+
+and vectorOfSexpr inputString3 =
+    let packed =
+        PC.pack
+            (PC.pack
+                (PC.caten hashtag (PC.caten (PC.char '\x28') (PC.caten (PC.star (PC.caten whitespaces_star (PC.delayed (fun () -> sexprLHS)))) (PC.caten whitespaces_star (PC.char '\x29')))))
+                (fun
+                    (hashTag,(lapren, (sexprList, spacesWithLparen))) ->
+                    List.fold_right (fun (spaceList, actualSexpr) acc -> actualSexpr :: acc)
+                    sexprList []
+                ))
+            (fun (gottenList) -> Vector (gottenList))
+        in
+    packed inputString3
+
+(* Vector - End *)
+
+(* Quoted - Start *)
+
+and quoted inputString4 =
+    let packed = PC.pack
+        (PC.caten (PC.char '\x27') (PC.caten whitespaces_star (PC.delayed (fun () -> sexprLHS))))
+        (fun (chupchik, (sapceList, sexpr)) -> Pair (Symbol ("quote"), Pair (sexpr, Nil))) in
+    packed inputString4
+
+(* Quoted - End *)
+
+(* QuasiQuoted - Start *)
+
+and quasiQuoted inputString5 =
+    let packed = PC.pack
+        (PC.caten (PC.char '\x60') (PC.caten whitespaces_star (PC.delayed (fun () -> sexprLHS))))
+        (fun (chupchik, (sapceList, sexpr)) -> Pair (Symbol ("quasiquote"), Pair (sexpr, Nil))) in
+    packed inputString5
+
+(* QuasiQuoted - End *)
+
+(* Unquoted - Start *)
+
+and unquoted inputString6 =
+    let packed = PC.pack
+        (PC.caten (PC.char ',') (PC.caten whitespaces_star (PC.delayed (fun () -> sexprLHS))))
+        (fun (chupchik, (sapceList, sexpr)) -> Pair (Symbol ("unquote"), Pair (sexpr, Nil))) in
+    packed inputString6
+
+(* Unquoted - End *)
+
+(* UnquoteAndSpliced - Start *)
+
+and unquoteAndSpliced inputString7 =
+    let packed = PC.pack
+        (PC.caten (PC.word ",@") (PC.caten whitespaces_star (PC.delayed (fun () -> sexprLHS))))
+        (fun (chupchik, (sapceList, sexpr)) -> Pair (Symbol ("unquote-splicing"), Pair (sexpr, Nil))) in
+    packed inputString7
+
+(* UnquoteAndSpliced - End *)
+
+(* Nil - Start *)
+
+and nil inputString8 =
+    let packed = PC.pack
+        (PC.caten (PC.char '\x28') (PC.caten whitespaces_star (PC.char '\x29')))
+        (fun (anything) -> Nil) in
+    packed inputString8
+
+(* Nil - End *)
+
+(* threeDots - Start *)
+
+and threeDots inputString10 =
+    let anyChar =
+        PC.star
+            (
+                PC.disj
+                    (PC.const (fun ch -> ch >= ' ' && ch <= '~' && ch != '.'))
+                    (PC.not_followed_by (PC.const (fun ch -> ch = '.')) (PC.const (fun ch -> ch = '.')))
+            )
+        in
+    let packed =
+        PC.pack
+            (PC.caten anyChar (PC.word "..."))
+            (fun (allChars, threeDotsSymbol) ->
+                List.fold_left
+                    (
+                        fun (allChars, acc) loneChar -> match loneChar with
+                                                        | '\x28' -> (allChars, '\x29' :: acc)
+                                                        | '\x5b' -> (allChars, '\x5d' :: acc)
+                                                        | '\x5d' -> (allChars, List.tl acc)
+                                                        | '\x29' -> (allChars, List.tl acc)
+                                                        | _ -> (allChars, acc)
+                    )
+                    (allChars, [])
+                    allChars
+            )
+    in
+    let ((input, fill), rest) = packed inputString10 in
+    sexprLHS (List.append input fill);;
+
+(* threeDots - End *)
+
+(* General Parser - Start *)
+
+let read_sexpr string =
+    let (returnValue, rest) = (sexprLHS (string_to_list string)) in
+    returnValue;;
+
+let read_sexprs string =
+    let (returnValue, rest) = ((PC.star sexprLHS) (string_to_list string)) in
+    returnValue;;
+
+(* General Parser - End *)
+
 end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..20c97bc 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Eran Atias (ID 305774838)
+Omer Hogeg (ID 204555957)
+
+We assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index dbd1601..3221392 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -6,7 +6,7 @@
 
 #use "tag-parser.ml";;
 
-type var = 
+type var =
   | VarFree of string
   | VarParam of string * int
   | VarBound of string * int * int;;
@@ -27,37 +27,31 @@ type expr' =
   | Applic' of expr' * (expr' list)
   | ApplicTP' of expr' * (expr' list);;
 
-let rec expr'_eq e1 e2 =
-  match e1, e2 with
+let rec expr'_eq e1 e2 = match e1, e2 with
   | Const' Void, Const' Void -> true
   | Const'(Sexpr s1), Const'(Sexpr s2) -> sexpr_eq s1 s2
   | Var'(VarFree v1), Var'(VarFree v2) -> String.equal v1 v2
   | Var'(VarParam (v1,mn1)), Var'(VarParam (v2,mn2)) -> String.equal v1 v2 && mn1 = mn2
   | Var'(VarBound (v1,mj1,mn1)), Var'(VarBound (v2,mj2,mn2)) -> String.equal v1 v2 && mj1 = mj2  && mn1 = mn2
-  | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) &&
-                                            (expr'_eq th1 th2) &&
-                                              (expr'_eq el1 el2)
+  | If'(t1, th1, el1), If'(t2, th2, el2) -> (expr'_eq t1 t2) && (expr'_eq th1 th2) && (expr'_eq el1 el2)
   | (Seq'(l1), Seq'(l2)
   | Or'(l1), Or'(l2)) -> List.for_all2 expr'_eq l1 l2
   | (Set'(var1, val1), Set'(var2, val2)
-  | Def'(var1, val1), Def'(var2, val2)) -> (expr'_eq var1 var2) &&
-                                             (expr'_eq val1 val2)
-  | LambdaSimple'(vars1, body1), LambdaSimple'(vars2, body2) ->
-     (List.for_all2 String.equal vars1 vars2) &&
-       (expr'_eq body1 body2)
-  | LambdaOpt'(vars1, var1, body1), LambdaOpt'(vars2, var2, body2) ->
-     (String.equal var1 var2) &&
-       (List.for_all2 String.equal vars1 vars2) &&
-         (expr'_eq body1 body2)
+  | Def'(var1, val1), Def'(var2, val2)) -> (expr'_eq var1 var2) && (expr'_eq val1 val2)
+  | LambdaSimple'(vars1, body1), LambdaSimple'(vars2, body2) -> (List.for_all2 String.equal vars1 vars2) && (expr'_eq body1 body2)
+  | LambdaOpt'(vars1, var1, body1), LambdaOpt'(vars2, var2, body2) -> (String.equal var1 var2) && (List.for_all2 String.equal vars1 vars2) && (expr'_eq body1 body2)
   | Applic'(e1, args1), Applic'(e2, args2)
-  | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
-	 (expr'_eq e1 e2) &&
-	   (List.for_all2 expr'_eq args1 args2)
+  | ApplicTP'(e1, args1), ApplicTP'(e2, args2) -> (expr'_eq e1 e2) && (List.for_all2 expr'_eq args1 args2)
+  | Box'(_), Box'(_) -> true
+  | BoxGet'(_), BoxGet'(_) -> true
+  | BoxSet'(_, v1), BoxSet'(_, v2) -> expr'_eq v1 v2
   | _ -> false;;
-	
-                       
+
+
 exception X_syntax_error;;
 
+let environment = ref [];;
+
 module type SEMANTICS = sig
   val run_semantics : expr -> expr'
   val annotate_lexical_addresses : expr -> expr'
@@ -67,15 +61,285 @@ end;;
 
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+let searchInEnvironment varibleName =
+  let varToReturn = ref [(VarFree (varibleName))] in
+  begin
+    for i = 0 to (List.length !environment - 1) do
+      for j = 0 to (List.length (List.nth !environment i) - 1) do
+        if (List.nth (List.nth !environment i) j) = varibleName
+          then
+            (if i = 0
+              then varToReturn := (!varToReturn) @ [VarParam (varibleName, j)]
+              else varToReturn := (!varToReturn) @ [VarBound (varibleName, i-1, j)])
+      done
+    done;
+  if List.length (!varToReturn) = 1
+    then List.nth (!varToReturn) 0
+    else List.nth (!varToReturn) 1
+  end;;
+
+let rec annotate_lexical_addresses e = match e with
+  | Const (x) -> Const' (x)
+  | Var (varibleName) -> Var' (searchInEnvironment varibleName)
+  | If (test, dit, dif) -> If' (annotate_lexical_addresses test, annotate_lexical_addresses dit, annotate_lexical_addresses dif)
+  | Seq (exprList) -> Seq' (List.map annotate_lexical_addresses exprList)
+  | Set (varibleName, newValue) -> Set' (annotate_lexical_addresses varibleName, annotate_lexical_addresses newValue)
+  | Def (varibleName, varibleValue) -> Def' (annotate_lexical_addresses varibleName, annotate_lexical_addresses varibleValue)
+  | Or (exprList) -> Or' (List.map annotate_lexical_addresses exprList)
+  | LambdaSimple (argList, expr) ->
+      begin
+        environment := argList :: !environment;
+        let lambdaSimpleToReturn = LambdaSimple' (argList, annotate_lexical_addresses expr)
+        in
+          begin
+            environment := List.tl !environment;
+            lambdaSimpleToReturn
+          end
+      end
+  | LambdaOpt (argList, additionalArg, expr) ->
+      begin
+        environment := (argList @ [additionalArg]) :: !environment;
+        let lambdaOptToReturn = LambdaOpt' (argList, additionalArg, annotate_lexical_addresses expr)
+        in
+          begin
+            environment := List.tl !environment;
+            lambdaOptToReturn
+          end
+      end
+  | Applic (procedureName, argList) -> Applic' (annotate_lexical_addresses procedureName, List.map annotate_lexical_addresses argList);;
+
+let rec annotate_tail_calls_helper e flag = match e with
+  | If' (test, dit, dif) -> if flag = true
+                            then If' (test, annotate_tail_calls_helper dit true, annotate_tail_calls_helper dif true)
+                            else If' (test, annotate_tail_calls_helper dit false, annotate_tail_calls_helper dif false)
+  | Seq' (exprList) -> if flag = true
+                        then Seq' (
+                                    List.map
+                                    (fun element -> if element = List.hd (List.rev exprList)
+                                                    then annotate_tail_calls_helper element true
+                                                    else annotate_tail_calls_helper element false)
+                                    exprList
+                                  )
+                        else Seq' (
+                                    List.map
+                                    (fun element -> if element = List.hd (List.rev exprList)
+                                                    then annotate_tail_calls_helper element false
+                                                    else annotate_tail_calls_helper element false)
+                                    exprList
+                                  )
+  | Set' (varibleName, newValue) -> Set' (varibleName, annotate_tail_calls_helper newValue false)
+  | Def' (varibleName, varibleValue) -> Def' (varibleName, annotate_tail_calls_helper varibleValue false)
+  | Or' (exprList) -> if flag = true
+                        then Or' (
+                                    List.map
+                                    (fun element -> if element = List.hd (List.rev exprList)
+                                                    then annotate_tail_calls_helper element true
+                                                    else annotate_tail_calls_helper element false)
+                                    exprList
+                                  )
+                        else Or' (
+                                    List.map
+                                    (fun element -> if element = List.hd (List.rev exprList)
+                                                    then annotate_tail_calls_helper element false
+                                                    else annotate_tail_calls_helper element false)
+                                    exprList
+                                  )
+  | LambdaSimple' (argList, expr) -> LambdaSimple' (argList, annotate_tail_calls_helper expr true)
+  | LambdaOpt' (argList, additionalArg, expr) -> LambdaOpt' (argList, additionalArg, annotate_tail_calls_helper expr true)
+  | Applic' (procedureName, argList) -> if flag = true
+                                          then ApplicTP' (
+                                                            annotate_tail_calls procedureName,
+                                                            List.map
+                                                            (fun arg -> annotate_tail_calls arg)
+                                                            argList
+                                                          )
+                                          else Applic' (
+                                                          annotate_tail_calls procedureName,
+                                                          List.map
+                                                          (fun arg -> annotate_tail_calls arg)
+                                                          argList
+                                                        )
+  | x -> x
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+and annotate_tail_calls e = annotate_tail_calls_helper e false;;
 
-let box_set e = raise X_not_yet_implemented;;
+let rec isThereRead arg expr = match expr with
+  | Const' (x) -> []
+  | Var' (varibleType) -> (match varibleType with
+      | VarFree (varibleName) -> []
+      | VarParam (varibleName, minor) -> if varibleName = arg then [Var' (VarFree (arg))] else []
+      | VarBound (varibleName, major, minor) -> if varibleName = arg then [Var' (VarFree (arg))] else [])
+  | If' (test, dit, dif) -> (isThereRead arg test) @ (isThereRead arg dit) @ (isThereRead arg dif)
+  | Seq' (exprList) -> List.fold_left
+                        (fun acc element -> acc @ (isThereRead arg element))
+                        []
+                        exprList
+  | Set' (varibleName, newValue) -> isThereRead arg newValue
+  | Def' (varibleName, varibleValue) -> isThereRead arg varibleValue
+  | Or' (exprList) -> List.fold_left
+                        (fun acc element -> acc @ (isThereRead arg element))
+                        []
+                        exprList
+  | LambdaSimple' (argList, innerExpr) -> if List.mem arg argList
+                                            then []
+                                            else (if (isThereRead arg innerExpr) <> [] then [expr] else [])
+  | LambdaOpt' (argList, additionalArg, innerExpr) -> if List.mem arg (argList @ [additionalArg])
+                                                        then []
+                                                        else (if (isThereRead arg innerExpr) <> [] then [expr] else [])
+  | Applic' (procedureName, argList) -> (isThereRead arg procedureName)
+                                        @
+                                        (List.fold_left
+                                          (fun acc element -> acc @ (isThereRead arg element))
+                                          []
+                                          argList)
+  | ApplicTP' (procedureName, argList) -> (isThereRead arg procedureName)
+                                          @
+                                          (List.fold_left
+                                            (fun acc element -> acc @ (isThereRead arg element))
+                                            []
+                                            argList)
+  | x -> [];;
+
+let rec isThereWrite arg expr = match expr with
+  | Const' (x) -> []
+  | Var' (varibleType) -> []
+  | If' (test, dit, dif) -> (isThereWrite arg test) @ (isThereWrite arg dit) @ (isThereWrite arg dif)
+  | Seq' (exprList) -> List.fold_left
+                        (fun acc element -> acc @ (isThereWrite arg element))
+                        []
+                        exprList
+  | Set' (Var' (varibleType), newValue) -> (match varibleType with
+    | VarFree (varibleName) -> isThereWrite arg newValue
+    | VarParam (varibleName, minor) -> if varibleName = arg then ([Var' (VarFree (arg))] @ (isThereWrite arg newValue)) else isThereWrite arg newValue
+    | VarBound (varibleName, major, minor) -> if varibleName = arg then ([Var' (VarFree (arg))] @ (isThereWrite arg newValue)) else isThereWrite arg newValue)
+  | Set' (x, y) -> raise X_syntax_error
+  | Def' (varibleName, varibleValue) -> isThereWrite arg varibleValue
+  | Or' (exprList) -> List.fold_left
+                        (fun acc element -> acc @ (isThereWrite arg element))
+                        []
+                        exprList
+  | LambdaSimple' (argList, innerExpr) -> if List.mem arg argList
+                                            then []
+                                            else (if (isThereWrite arg innerExpr) <> [] then [expr] else [])
+  | LambdaOpt' (argList, additionalArg, innerExpr) -> if List.mem arg argList
+                                                        then []
+                                                        else (if (isThereWrite arg innerExpr) <> [] then [expr] else [])
+  | Applic' (procedureName, argList) -> (isThereWrite arg procedureName)
+                                        @
+                                        (List.fold_left
+                                          (fun acc element -> acc @ (isThereWrite arg element))
+                                          []
+                                          argList)
+  | ApplicTP' (procedureName, argList) -> (isThereWrite arg procedureName)
+                                          @
+                                          (List.fold_left
+                                            (fun acc element -> acc @ (isThereWrite arg element))
+                                            []
+                                            argList)
+  | x -> [];;
+
+let isWrapNeeded arg expr =
+  let readList = isThereRead arg expr in
+  let readListThreshold = if List.mem (Var' (VarFree (arg))) readList then 0 else 1 in
+  let writeList =  isThereWrite arg expr in
+  let writeListThreshold = if List.mem (Var' (VarFree (arg))) writeList then 0 else 1 in
+  let readListFiltered = List.filter (fun element -> element <> Var' (VarFree (arg))) readList in
+  let writeListFiltered = List.filter (fun element -> element <> Var' (VarFree (arg))) writeList in
+  let readListFilteredLength = List.length readListFiltered in
+  let writeListFilteredLength = List.length writeListFiltered in
+  if readListFilteredLength > readListThreshold && writeListFilteredLength >= writeListThreshold
+    then true
+  else if readListFilteredLength >= readListThreshold && writeListFilteredLength > writeListThreshold
+    then true
+  else if readListFilteredLength = readListThreshold && writeListFilteredLength = writeListThreshold && readListFiltered <> writeListFiltered
+      then true
+  else false;;
+
+let rec box_set_wrapper e varibleListToWrap = match e with
+  | Const' (x) -> Const' (x)
+  | Var' (varibleType) -> (match varibleType with
+      | VarFree (varibleName) -> Var' (VarFree (varibleName))
+      | VarParam (varibleName, minor) -> if List.mem varibleName varibleListToWrap
+                                          then BoxGet' (VarParam (varibleName, minor))
+                                          else Var' (VarParam (varibleName, minor))
+      | VarBound (varibleName, major, minor) ->  if List.mem varibleName varibleListToWrap
+                                                  then BoxGet' (VarBound (varibleName, major, minor))
+                                                  else Var' (VarBound (varibleName, major, minor)))
+  | If' (test, dit, dif) -> If' (box_set_wrapper test varibleListToWrap, box_set_wrapper dit varibleListToWrap, box_set_wrapper dif varibleListToWrap)
+  | Seq' (exprList) -> Seq' (
+                              List.map
+                                (fun element -> box_set_wrapper element varibleListToWrap)
+                                exprList
+                            )
+  | Set' (Var' (varibleType), newValue) -> (match varibleType with
+    | VarFree (varibleName) -> Set' (Var' (varibleType),  box_set_wrapper newValue varibleListToWrap)
+    | VarParam (varibleName, minor) -> if List.mem varibleName varibleListToWrap
+                                        then BoxSet' (VarParam (varibleName, minor), box_set_wrapper newValue varibleListToWrap)
+                                        else Set' (Var' varibleType, box_set_wrapper newValue varibleListToWrap)
+    | VarBound (varibleName, major, minor) -> if List.mem varibleName varibleListToWrap
+                                                then BoxSet' (VarBound (varibleName, major, minor), box_set_wrapper newValue varibleListToWrap)
+                                                else Set' (Var' varibleType, box_set_wrapper newValue varibleListToWrap))
+  | Set' (x, y) -> raise X_syntax_error
+  | Def' (varibleName, varibleValue) -> Def' (varibleName, box_set_wrapper varibleValue varibleListToWrap)
+  | Or' (exprList) -> Or' (
+                            List.map
+                              (fun element -> box_set_wrapper element varibleListToWrap)
+                              exprList
+                          )
+  | LambdaSimple' (argList, expr) ->
+      let serachInList argToFind =
+        let indexToReturn = ref (-1) in
+        begin
+          (for i = 0 to (List.length argList - 1) do (if (List.nth argList i) = argToFind then indexToReturn := i) done);
+          !indexToReturn
+        end in
+      let isWrapNeededArgs = (List.filter (fun element -> isWrapNeeded element expr) argList) in
+      let argsToWrap = (List.filter (fun oldArg -> not (List.mem oldArg argList)) varibleListToWrap) @ isWrapNeededArgs in
+      let newExpr = box_set_wrapper expr argsToWrap in
+      let newBodyPrefix = List.map (fun argToWrap -> (Set' (Var' (VarParam (argToWrap, serachInList argToWrap)), Box' (VarParam (argToWrap, serachInList argToWrap))))) isWrapNeededArgs in
+      if List.length newBodyPrefix = 0
+          then LambdaSimple' (argList, newExpr)
+          else
+            (match newExpr with
+              | Seq' (exprList) -> LambdaSimple' (argList, Seq' (newBodyPrefix @ [Seq' (exprList)]))
+              | x -> LambdaSimple' (argList, Seq' (newBodyPrefix @ [x])))
+  | LambdaOpt' (argList, additionalArg, expr) ->
+      let argListWithAdditional = argList @ [additionalArg] in
+      let serachInList argToFind =
+        let indexToReturn = ref (-1) in
+        begin
+          (for i = 0 to (List.length argListWithAdditional - 1) do (if ((List.nth argListWithAdditional i) = argToFind) then indexToReturn := i) done);
+          !indexToReturn
+        end in
+      let isWrapNeededArgs = (List.filter (fun element -> isWrapNeeded element expr) argListWithAdditional) in
+      let argsToWrap = (List.filter (fun oldArg -> not (List.mem oldArg argListWithAdditional)) varibleListToWrap) @ isWrapNeededArgs in
+      let newExpr = box_set_wrapper expr argsToWrap in
+      let newBodyPrefix = List.map (fun argToWrap -> Set' (Var' (VarParam (argToWrap, serachInList argToWrap)), Box' (VarParam (argToWrap, serachInList argToWrap)))) isWrapNeededArgs in
+      if List.length newBodyPrefix = 0
+        then LambdaOpt' (argList, additionalArg, newExpr)
+        else
+          (match newExpr with
+            | Seq' (exprList) -> LambdaOpt' (argList, additionalArg, Seq' (newBodyPrefix @ [Seq' (exprList)]))
+            | x -> LambdaOpt' (argList, additionalArg, Seq' (newBodyPrefix @ [x])))
+  | Applic' (procedureName, argList) -> Applic' (
+                                                  box_set_wrapper procedureName varibleListToWrap,
+                                                  List.map
+                                                    (fun element -> box_set_wrapper element varibleListToWrap)
+                                                    argList
+                                                )
+  | ApplicTP' (procedureName, argList) -> ApplicTP' (
+                                                      box_set_wrapper procedureName varibleListToWrap,
+                                                      List.map
+                                                        (fun element -> box_set_wrapper element varibleListToWrap)
+                                                        argList
+                                                    )
+  | _ -> raise X_syntax_error;;
+
+let box_set e = box_set_wrapper e [];;
 
 let run_semantics expr =
   box_set
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
-  
+
 end;; (* struct Semantics *)
diff --git a/stdlib.scm b/stdlib.scm
index 1188438..29a70e6 100644
--- a/stdlib.scm
+++ b/stdlib.scm
@@ -46,12 +46,10 @@
 	    ((= 1 (length y)) (make-vector x (car y)))
 	    (else "this should be an error, but you don't support exceptions")))))
 
-
-
 (define not
   (let ((eq? eq?))
     (lambda (x)
-      (if (eq? x #t) #f #t))))
+      (if (eq? x #f) #t #f))))
 
 (define number?
   (let ((float? float?) (integer? integer?))
diff --git a/tag-parser.ml b/tag-parser.ml
index 619497a..851afc2 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -46,8 +46,8 @@ let rec expr_eq e1 e2 =
      (expr_eq e1 e2) &&
        (List.for_all2 expr_eq args1 args2)
   | _ -> false;;
-	
-                       
+
+
 exception X_syntax_error;;
 
 module type TAG_PARSER = sig
@@ -61,13 +61,343 @@ let reserved_word_list =
   ["and"; "begin"; "cond"; "define"; "else";
    "if"; "lambda"; "let"; "let*"; "letrec"; "or";
    "quasiquote"; "quote"; "set!"; "unquote";
-   "unquote-splicing"];;  
+   "unquote-splicing"];;
+
+let rec tag_parse sexpr = match sexpr with
+  | Bool (x) -> Const (Sexpr (Bool (x)))
+  | Number (x) -> Const (Sexpr (Number (x)))
+  | Char (x) -> Const (Sexpr (Char (x)))
+  | String (x) -> Const (Sexpr (String (x)))
+  | Symbol (x) ->
+      if (List.mem x reserved_word_list) then raise X_syntax_error else Var (x)
+  | Nil -> Const (Void)
+  | Pair (Symbol ("quote"), Pair (x, Nil)) -> Const (Sexpr (x))
+  | Pair (Symbol ("if"), Pair (test, Pair (dit, Pair (dif, Nil)))) -> If (tag_parse test, tag_parse dit, tag_parse dif)
+  | Pair (Symbol ("if"), Pair (test, Pair (dit, Nil))) -> If (tag_parse test, tag_parse dit, Const (Void))
+  | Pair (Symbol ("lambda"), Pair (Symbol varible, sexprs)) -> LambdaOpt ([], varible, sexprsToExprListToSeq sexprs) (* Lambda Type 3 *)
+  | Pair (Symbol ("lambda"), Pair (bindings, Nil)) -> raise X_syntax_error
+  | Pair (Symbol ("lambda"), Pair (bindings, sexprs)) ->
+      (
+        try LambdaSimple (lambdaSimpleBindingsToStringList bindings, sexprsToExprListToSeq sexprs) (* Lambda Type 1 *)
+        with X_syntax_error -> buildLabmdaOpt (bindings, sexprs) (* Lambda Type 2 *)
+      )
+  | Pair (Symbol "or", args) -> sexprsToExprListToOr args
+  | Pair (Symbol "define", Pair (Symbol (varibleName), Pair (varibleValue, Nil))) -> Def (tag_parse (Symbol (varibleName)), tag_parse (varibleValue)) (* Define - Regular *)
+  | Pair (Symbol "define", Pair (Pair (Symbol (varibleName), arguments), sexprs)) -> tag_parse (Pair (Symbol "define", Pair (Symbol (varibleName), Pair (Pair (Symbol "lambda", Pair (arguments, sexprs)), Nil)))) (* MIT-Define *)
+  | Pair (Symbol "set!", Pair (Symbol varibleName, Pair (newValue, Nil))) -> Set (tag_parse (Symbol (varibleName)), tag_parse (newValue))
+  | Pair (Symbol "begin", Nil) -> Const (Void) (* Begin - Empty *)
+  | Pair (Symbol "begin", Pair (singleSexpr, Nil)) -> tag_parse singleSexpr (* Begin - Single Expression *)
+  | Pair (Symbol "begin", Pair (firstSexpr, restSexprs)) -> exprListToSeq ((tag_parse firstSexpr) :: (sexprsToExprList restSexprs)) (* Begin - Multiple Expressions *)
+  | Pair (Symbol "let", Pair (Nil, sexprs)) -> Applic (LambdaSimple ([], sexprsToExprListToSeq sexprs), []) (* Let - No Bindings *)
+  | Pair (Symbol "let", Pair (bindings, sexprs)) -> Applic (LambdaSimple (getVariblesForLet bindings, sexprsToExprListToSeq sexprs), getArgumentsForLet bindings) (* Let - With Bindings *)
+  | Pair (Symbol "let*", Pair (Nil, sexprs)) -> tag_parse (Pair (Symbol "let", Pair (Nil, sexprs))) (* Let* - No Bindings *)
+  | Pair (Symbol "let*", Pair (Pair (singleBinding, Nil), sexprs)) -> tag_parse (Pair (Symbol "let", Pair (Pair (singleBinding, Nil), sexprs))) (* Let* - Single Binding *)
+  | Pair (Symbol "let*", Pair (Pair (firstBinding, restBindings), sexprs)) -> tag_parse (letStarToLet sexpr) (* Let* - Multiple Bindings *)
+  | Pair (Symbol "letrec", Pair (bindings, sexprs)) -> Applic (LambdaSimple (getVariblesForLet bindings, getExprsForLetrecToSeq (bindings, sexprs)), createWhateverForLetrec bindings)
+  | Pair (Symbol "and", Nil) -> Const (Sexpr (Bool (true))) (* And - Empty *)
+  | Pair (Symbol "and", Pair (singleSexpr, Nil)) -> tag_parse singleSexpr (* And - Single Expression *)
+  | Pair (Symbol "and", Pair (firstSexpr, restSexprs)) -> andToIf (firstSexpr, restSexprs) (* And - Multiple Expressions *)
+  | Pair (Symbol "cond", Nil) -> Const (Void) (* Cond - Empty ??? *)
+  | Pair (Symbol "cond", Pair (firstRib, restRibs)) -> condToIf (firstRib,restRibs)
+  | Pair (Pair (Symbol "lambda", lambdaSpecifications), arguments) -> Applic (tag_parse (Pair (Symbol "lambda", lambdaSpecifications)), sexprsToExprList arguments)
+  | Pair (Symbol "quasiquote", Pair (sexpr, Nil)) -> handleQuasiquote sexpr
+  | Pair (procedure, args) -> Applic (tag_parse procedure, sexprsToExprList args)
+  | _ -> raise X_syntax_error
+
+and sexprsToExprList sexprs = match sexprs with
+  | Pair (sexpr, rest) -> (tag_parse sexpr) :: (sexprsToExprList rest)
+  | Nil -> []
+  | _ -> raise X_syntax_error
+
+and sexprsToExprListToSeq sexprs = match (sexprsToExprList sexprs) with
+  | [] -> Const (Void)
+  | [singleElement] -> singleElement
+  | _ -> Seq (sexprsToExprList sexprs)
+
+and sexprsToExprListToOr sexprs = match (sexprsToExprList sexprs) with
+  | [] -> Const(Sexpr(Bool(false)))
+  | [singleElement] -> singleElement
+  | _ -> Or (sexprsToExprList sexprs)
+
+and exprListToSeq exprs = match exprs with
+  | [] -> Const (Void)
+  | [singleElement] -> singleElement
+  | _ -> Seq (exprs)
+
+and lambdaSimpleBindingsToStringList bindings = match bindings with
+  | Pair (Symbol varible, rest) ->
+      if (List.mem varible (lambdaSimpleBindingsToStringList rest)) then raise X_syntax_error else (varible :: (lambdaSimpleBindingsToStringList rest))
+  | Nil -> []
+  | _ -> raise X_syntax_error
+
+and buildLabmdaOpt (bindings, sexprs) =
+  let rec lambdaOptBindingsToStringList bindings = match bindings with
+    | Pair (Symbol varible, rest) ->
+        if (List.mem varible (lambdaOptBindingsToStringList rest)) then raise X_syntax_error else (varible :: (lambdaOptBindingsToStringList rest))
+    | Symbol lastVarible -> [lastVarible]
+    | _ -> raise X_syntax_error
+  in
+  let bindingsToList = lambdaOptBindingsToStringList bindings in
+  let (varibles, additionalVarible) = ((List.rev (List.tl (List.rev bindingsToList)), List.hd (List.rev (bindingsToList)))) in
+  LambdaOpt (varibles, additionalVarible, sexprsToExprListToSeq sexprs)
+
+and getVariblesForLet bindings = match bindings with
+  | Pair (Pair (Symbol (firstVarible), firstVaribleValue), restVaribles) ->
+      if (List.mem firstVarible (getVariblesForLet restVaribles)) then raise X_syntax_error else (firstVarible :: (getVariblesForLet restVaribles))
+  | Nil -> []
+  | _ -> raise X_syntax_error
+
+and getArgumentsForLet bindings = match bindings with
+  | Pair (Pair (firstVarible, Pair(actualfirstVaribleValue, endOfPair)), restVaribles) -> (tag_parse actualfirstVaribleValue) :: (getArgumentsForLet restVaribles)
+  | Nil -> []
+  | _ -> raise X_syntax_error
+
+and letStarToLet sexpr =  match sexpr with
+  | Pair (Symbol "let*", Pair (Pair (singleBinding, Nil), sexprs)) -> Pair (Symbol "let", Pair (Pair (singleBinding, Nil), sexprs))
+  | Pair (Symbol "let*", Pair (Pair (firstBinding, restBindings), sexprs)) -> Pair (Symbol "let", Pair (Pair (firstBinding, Nil), Pair (letStarToLet (Pair (Symbol "let*", Pair (restBindings, sexprs))), Nil)))
+  | _ -> raise X_syntax_error
+
+and getExprsForLetrec (bindings, sexprs) =
+  List.fold_right2
+    (fun currentVarible currentArgument acc -> Set (tag_parse (Symbol (currentVarible)), currentArgument) :: acc)
+    (getVariblesForLet bindings)
+    (getArgumentsForLet bindings)
+    (sexprsToExprList sexprs)
+
+and getExprsForLetrecToSeq (bindings, sexprs) = match (getExprsForLetrec (bindings, sexprs)) with
+  | [] -> Const (Void)
+  | [singleElement] -> singleElement
+  | _ -> Seq (getExprsForLetrec (bindings, sexprs))
+
+and createWhateverForLetrec bindings =
+  List.fold_right
+  (fun currentVarible acc -> tag_parse (Pair (Symbol "quote", Pair (Symbol "whatever", Nil))) :: acc)
+  (getVariblesForLet bindings)
+  []
+
+and andToIf (firstSexpr, restSexprs) =
+  If
+  (
+    tag_parse firstSexpr,
+    tag_parse (Pair (Symbol "and", restSexprs)),
+    Const (Sexpr (Bool (false)))
+  )
+
+and condToIf (firstRib, restRibs) =
+  match firstRib with
+    | Pair (Symbol "else", sexprs) -> if (restRibs = Nil) then sexprsToExprListToSeq sexprs else raise X_syntax_error
+    | Pair (test, Pair (Symbol "=>", Pair (exprf, Nil))) ->
+        if (restRibs = Nil)
+        then
+          tag_parse
+            (
+              Pair
+              (
+                Symbol "let",
+                Pair
+                (
+                  Pair
+                  (
+                    Pair
+                    (
+                      Symbol "value",
+                      Pair (test, Nil)
+                    ),
+                    Pair
+                    (
+                      Pair
+                      (
+                        Symbol "f",
+                        Pair
+                        (
+                          Pair
+                          (
+                            Symbol "lambda",
+                            Pair
+                            (
+                              Nil,
+                              Pair (exprf, Nil)
+                            )
+                          ),
+                          Nil
+                        )
+                      ),
+                      Nil
+                    )
+                  ),
+                  Pair
+                  (
+                    Pair
+                    (Symbol "if",
+                      Pair
+                      (
+                        Symbol "value",
+                        Pair
+                        (
+                          Pair
+                          (
+                            Pair (Symbol "f", Nil),
+                            Pair (Symbol "value", Nil)
+                          ),
+                          Nil
+                        )
+                      )
+                    ),
+                    Nil
+                  )
+                )
+              )
+            )
+        else
+        tag_parse
+        (
+          Pair
+          (
+            Symbol "let",
+            Pair
+            (
+              Pair
+              (
+                Pair
+                (
+                  Symbol "value",
+                  Pair (test, Nil)
+                ),
+                Pair
+                (
+                  Pair
+                  (
+                    Symbol "f",
+                    Pair
+                    (
+                      Pair
+                      (
+                        Symbol "lambda",
+                        Pair
+                        (
+                          Nil,
+                          Pair (exprf, Nil)
+                        )
+                      ),
+                      Nil
+                    )
+                  ),
+                  Pair
+                  (
+                    Pair
+                    (
+                      Symbol "rest",
+                      Pair
+                      (
+                        Pair
+                        (
+                          Symbol "lambda",
+                          Pair
+                          (
+                            Nil,
+                            Pair
+                            (
+                              Pair
+                              (
+                                Symbol "cond",
+                                restRibs
+                              ),
+                              Nil
+                            )
+                          )
+                        ),
+                        Nil
+                      )
+                    ),
+                    Nil
+                  )
+                )
+              ),
+              Pair
+              (
+                Pair
+                (
+                  Symbol "if",
+                  Pair
+                  (
+                    Symbol "value",
+                    Pair
+                    (
+                      Pair
+                      (
+                        Pair (Symbol "f", Nil),
+                        Pair (Symbol "value", Nil)
+                      ),
+                      Pair
+                      (
+                        Pair
+                        (
+                          Symbol "rest",
+                          Nil
+                        ),
+                        Nil
+                      )
+                    )
+                  )
+                ),
+                Nil
+              )
+            )
+          )
+        )
+    | Pair (test, sexprs) -> If (tag_parse test, sexprsToExprListToSeq sexprs, tag_parse (Pair (Symbol "cond", restRibs)))
+    | _ -> raise X_syntax_error
+
+and handleQuasiquote sexpr = match sexpr with
+  | Pair (Symbol "unquote", Pair (element, Nil)) -> tag_parse element
+  | Pair (Symbol "unquote-splicing", Pair (element, Nil)) -> raise X_syntax_error
+  | Pair (Pair (Symbol "unquote-splicing", Pair (firstElement, Nil)), restElements) ->
+      Applic
+        (
+          Var ("append"),
+          [
+            tag_parse firstElement;
+            handleQuasiquote restElements
+          ]
+        )
+  | Pair (firstElement, Pair (Symbol "unquote-splicing", Pair (currentElement, Nil))) ->
+      Applic
+      (
+        Var ("cons"),
+        [
+          handleQuasiquote firstElement;
+          tag_parse currentElement
+        ]
+      )
+  | Pair (firstElement, Pair (Pair (Symbol "unquote-splicing", restElements), Nil)) ->
+      Applic
+        (
+          Var ("cons"),
+          [
+            handleQuasiquote firstElement;
+            handleQuasiquote (Pair (Pair (Symbol "unquote-splicing", restElements), Nil))
+          ]
+        )
+  | Vector (listInVector) ->
+      Applic
+        (
+          Var ("vector"),
+          List.map (fun currentElement ->  tag_parse (Pair (Symbol "quasiquote", Pair (currentElement, Nil)))) listInVector
+        )
+  | Pair (firstElement, restElements) ->
+      Applic
+        (
+          Var ("cons"),
+          [
+            handleQuasiquote firstElement;
+            handleQuasiquote restElements
+          ]
+        )
+  | x -> Const (Sexpr (x))
 
-(* work on the tag parser starts here *)
+let tag_parse_expression sexpr = tag_parse sexpr;;
 
-let tag_parse_expression sexpr = raise X_not_yet_implemented;;
+let tag_parse_expressions sexpr = List.map tag_parse_expression sexpr;;
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
 
-  
 end;; (* struct Tag_Parser *)
